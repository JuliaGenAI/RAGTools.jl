<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · RAGTools.jl</title><meta name="title" content="API Reference · RAGTools.jl"/><meta property="og:title" content="API Reference · RAGTools.jl"/><meta property="twitter:title" content="API Reference · RAGTools.jl"/><meta name="description" content="Documentation for RAGTools.jl."/><meta property="og:description" content="Documentation for RAGTools.jl."/><meta property="twitter:description" content="Documentation for RAGTools.jl."/><meta property="og:url" content="https://github.com/JuliaGenAI/RAGTools.jl/api_reference/"/><meta property="twitter:url" content="https://github.com/JuliaGenAI/RAGTools.jl/api_reference/"/><link rel="canonical" href="https://github.com/JuliaGenAI/RAGTools.jl/api_reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RAGTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Example</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGenAI/RAGTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/main/docs/src/api_reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="RAGTools"><a class="docs-heading-anchor" href="#RAGTools">RAGTools</a><a id="RAGTools-1"></a><a class="docs-heading-anchor-permalink" href="#RAGTools" title="Permalink"></a></h1><p>This is a meta-package exporting <a href="https://svilupp.github.io/PromptingTools.jl/dev/">PromptingTools</a> RAGTools sub-module and it&#39;s key dependencies to simplify the workflow. A simple quality of life improvement.</p><p>For details on how to use RAGTools see the <a href="https://svilupp.github.io/PromptingTools.jl/dev/extra_tools/rag_tools_intro">manual</a>.</p><ul><li><a href="#RAGTools.AbstractCandidateChunks"><code>RAGTools.AbstractCandidateChunks</code></a></li><li><a href="#RAGTools.AbstractChunkIndex"><code>RAGTools.AbstractChunkIndex</code></a></li><li><a href="#RAGTools.AbstractGenerator"><code>RAGTools.AbstractGenerator</code></a></li><li><a href="#RAGTools.AbstractIndexBuilder"><code>RAGTools.AbstractIndexBuilder</code></a></li><li><a href="#RAGTools.AbstractMultiIndex"><code>RAGTools.AbstractMultiIndex</code></a></li><li><a href="#RAGTools.AbstractRetriever"><code>RAGTools.AbstractRetriever</code></a></li><li><a href="#RAGTools.AdvancedGenerator"><code>RAGTools.AdvancedGenerator</code></a></li><li><a href="#RAGTools.AdvancedRetriever"><code>RAGTools.AdvancedRetriever</code></a></li><li><a href="#RAGTools.AllTagFilter"><code>RAGTools.AllTagFilter</code></a></li><li><a href="#RAGTools.AnnotatedNode"><code>RAGTools.AnnotatedNode</code></a></li><li><a href="#RAGTools.AnyTagFilter"><code>RAGTools.AnyTagFilter</code></a></li><li><a href="#RAGTools.BM25Similarity"><code>RAGTools.BM25Similarity</code></a></li><li><a href="#RAGTools.BatchEmbedder"><code>RAGTools.BatchEmbedder</code></a></li><li><a href="#RAGTools.BinaryBatchEmbedder"><code>RAGTools.BinaryBatchEmbedder</code></a></li><li><a href="#RAGTools.BinaryCosineSimilarity"><code>RAGTools.BinaryCosineSimilarity</code></a></li><li><a href="#RAGTools.BitPackedBatchEmbedder"><code>RAGTools.BitPackedBatchEmbedder</code></a></li><li><a href="#RAGTools.BitPackedCosineSimilarity"><code>RAGTools.BitPackedCosineSimilarity</code></a></li><li><a href="#RAGTools.CandidateChunks"><code>RAGTools.CandidateChunks</code></a></li><li><a href="#RAGTools.ChunkEmbeddingsIndex"><code>RAGTools.ChunkEmbeddingsIndex</code></a></li><li><a href="#RAGTools.ChunkKeywordsIndex-Tuple{RAGTools.AbstractProcessor, ChunkEmbeddingsIndex}"><code>RAGTools.ChunkKeywordsIndex</code></a></li><li><a href="#RAGTools.ChunkKeywordsIndex"><code>RAGTools.ChunkKeywordsIndex</code></a></li><li><a href="#RAGTools.CohereReranker"><code>RAGTools.CohereReranker</code></a></li><li><a href="#RAGTools.ContextEnumerator"><code>RAGTools.ContextEnumerator</code></a></li><li><a href="#RAGTools.CosineSimilarity"><code>RAGTools.CosineSimilarity</code></a></li><li><a href="#RAGTools.DocumentTermMatrix"><code>RAGTools.DocumentTermMatrix</code></a></li><li><a href="#RAGTools.FileChunker"><code>RAGTools.FileChunker</code></a></li><li><a href="#RAGTools.FlashRanker"><code>RAGTools.FlashRanker</code></a></li><li><a href="#RAGTools.HTMLStyler"><code>RAGTools.HTMLStyler</code></a></li><li><a href="#RAGTools.HyDERephraser"><code>RAGTools.HyDERephraser</code></a></li><li><a href="#RAGTools.JudgeAllScores"><code>RAGTools.JudgeAllScores</code></a></li><li><a href="#RAGTools.JudgeRating"><code>RAGTools.JudgeRating</code></a></li><li><a href="#RAGTools.KeywordsIndexer"><code>RAGTools.KeywordsIndexer</code></a></li><li><a href="#RAGTools.KeywordsProcessor"><code>RAGTools.KeywordsProcessor</code></a></li><li><a href="#RAGTools.MultiCandidateChunks"><code>RAGTools.MultiCandidateChunks</code></a></li><li><a href="#RAGTools.MultiFinder"><code>RAGTools.MultiFinder</code></a></li><li><a href="#RAGTools.MultiIndex"><code>RAGTools.MultiIndex</code></a></li><li><a href="#RAGTools.NoEmbedder"><code>RAGTools.NoEmbedder</code></a></li><li><a href="#RAGTools.NoPostprocessor"><code>RAGTools.NoPostprocessor</code></a></li><li><a href="#RAGTools.NoProcessor"><code>RAGTools.NoProcessor</code></a></li><li><a href="#RAGTools.NoRefiner"><code>RAGTools.NoRefiner</code></a></li><li><a href="#RAGTools.NoRephraser"><code>RAGTools.NoRephraser</code></a></li><li><a href="#RAGTools.NoReranker"><code>RAGTools.NoReranker</code></a></li><li><a href="#RAGTools.NoTagFilter"><code>RAGTools.NoTagFilter</code></a></li><li><a href="#RAGTools.NoTagger"><code>RAGTools.NoTagger</code></a></li><li><a href="#RAGTools.OpenTagger"><code>RAGTools.OpenTagger</code></a></li><li><a href="#RAGTools.PassthroughTagger"><code>RAGTools.PassthroughTagger</code></a></li><li><a href="#RAGTools.RAGConfig"><code>RAGTools.RAGConfig</code></a></li><li><a href="#RAGTools.RAGResult"><code>RAGTools.RAGResult</code></a></li><li><a href="#RAGTools.RankGPTReranker"><code>RAGTools.RankGPTReranker</code></a></li><li><a href="#RAGTools.RankGPTResult"><code>RAGTools.RankGPTResult</code></a></li><li><a href="#RAGTools.SimpleAnswerer"><code>RAGTools.SimpleAnswerer</code></a></li><li><a href="#RAGTools.SimpleBM25Retriever"><code>RAGTools.SimpleBM25Retriever</code></a></li><li><a href="#RAGTools.SimpleGenerator"><code>RAGTools.SimpleGenerator</code></a></li><li><a href="#RAGTools.SimpleIndexer"><code>RAGTools.SimpleIndexer</code></a></li><li><a href="#RAGTools.SimpleRefiner"><code>RAGTools.SimpleRefiner</code></a></li><li><a href="#RAGTools.SimpleRephraser"><code>RAGTools.SimpleRephraser</code></a></li><li><a href="#RAGTools.SimpleRetriever"><code>RAGTools.SimpleRetriever</code></a></li><li><a href="#RAGTools.Styler"><code>RAGTools.Styler</code></a></li><li><a href="#RAGTools.SubChunkIndex"><code>RAGTools.SubChunkIndex</code></a></li><li><a href="#RAGTools.SubDocumentTermMatrix"><code>RAGTools.SubDocumentTermMatrix</code></a></li><li><a href="#RAGTools.TavilySearchRefiner"><code>RAGTools.TavilySearchRefiner</code></a></li><li><a href="#RAGTools.TextChunker"><code>RAGTools.TextChunker</code></a></li><li><a href="#RAGTools.TrigramAnnotater"><code>RAGTools.TrigramAnnotater</code></a></li><li><a href="#PromptingTools.last_message-Tuple{RAGResult}"><code>PromptingTools.last_message</code></a></li><li><a href="#PromptingTools.last_output-Tuple{RAGResult}"><code>PromptingTools.last_output</code></a></li><li><a href="#PromptingTools.pprint-Tuple{IO, RAGTools.AbstractRAGResult}"><code>PromptingTools.pprint</code></a></li><li><a href="#PromptingTools.pprint-Tuple{IO, RAGTools.AbstractAnnotatedNode}"><code>PromptingTools.pprint</code></a></li><li><a href="#RAGTools.add_node_metadata!-Tuple{TrigramAnnotater, RAGTools.AnnotatedNode}"><code>RAGTools.add_node_metadata!</code></a></li><li><a href="#RAGTools.airag-Tuple{RAGTools.AbstractRAGConfig, RAGTools.AbstractDocumentIndex}"><code>RAGTools.airag</code></a></li><li><a href="#RAGTools.align_node_styles!-Tuple{TrigramAnnotater, AbstractVector{&lt;:RAGTools.AnnotatedNode}}"><code>RAGTools.align_node_styles!</code></a></li><li><a href="#RAGTools.annotate_support-Tuple{TrigramAnnotater, AbstractString, AbstractVector}"><code>RAGTools.annotate_support</code></a></li><li><a href="#RAGTools.annotate_support-Tuple{TrigramAnnotater, RAGTools.AbstractRAGResult}"><code>RAGTools.annotate_support</code></a></li><li><a href="#RAGTools.answer!-Tuple{RAGTools.SimpleAnswerer, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.answer!</code></a></li><li><a href="#RAGTools.bm25-Tuple{RAGTools.AbstractDocumentTermMatrix, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.bm25</code></a></li><li><a href="#RAGTools.build_context-Tuple{RAGTools.ContextEnumerator, RAGTools.AbstractDocumentIndex, RAGTools.AbstractCandidateChunks}"><code>RAGTools.build_context</code></a></li><li><a href="#RAGTools.build_index-Tuple{KeywordsIndexer, Vector{&lt;:AbstractString}}"><code>RAGTools.build_index</code></a></li><li><a href="#RAGTools.build_index-Tuple{RAGTools.AbstractIndexBuilder, Vector{&lt;:AbstractString}}"><code>RAGTools.build_index</code></a></li><li><a href="#RAGTools.build_qa_evals-Tuple{Vector{&lt;:AbstractString}, Vector{&lt;:AbstractString}}"><code>RAGTools.build_qa_evals</code></a></li><li><a href="#RAGTools.build_tags"><code>RAGTools.build_tags</code></a></li><li><a href="#RAGTools.build_tags-Tuple{RAGTools.AbstractTagger, Nothing}"><code>RAGTools.build_tags</code></a></li><li><a href="#RAGTools.build_tags-Tuple{RAGTools.AbstractTagger, AbstractVector{&lt;:AbstractVector{&lt;:AbstractString}}}"><code>RAGTools.build_tags</code></a></li><li><a href="#RAGTools.chunkdata-Tuple{SubChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.chunkdata</code></a></li><li><a href="#RAGTools.chunkdata-Tuple{ChunkKeywordsIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.chunkdata</code></a></li><li><a href="#RAGTools.chunkdata-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.chunkdata</code></a></li><li><a href="#RAGTools.cohere_api-Tuple{}"><code>RAGTools.cohere_api</code></a></li><li><a href="#RAGTools.create_permutation_instruction-Tuple{AbstractVector{&lt;:AbstractString}}"><code>RAGTools.create_permutation_instruction</code></a></li><li><a href="#RAGTools.create_websearch-Tuple{AbstractString}"><code>RAGTools.create_websearch</code></a></li><li><a href="#RAGTools.document_term_matrix-Union{Tuple{AbstractVector{&lt;:AbstractVector{T}}}, Tuple{T}} where T&lt;:AbstractString"><code>RAGTools.document_term_matrix</code></a></li><li><a href="#RAGTools.extract_ranking-Tuple{AbstractString}"><code>RAGTools.extract_ranking</code></a></li><li><a href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a></li><li><a href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a></li><li><a href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a></li><li><a href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a></li><li><a href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a></li><li><a href="#RAGTools.find_tags-Tuple{RAGTools.AnyTagFilter, RAGTools.AbstractChunkIndex, Union{Regex, AbstractString}}"><code>RAGTools.find_tags</code></a></li><li><a href="#RAGTools.find_tags-Union{Tuple{T}, Tuple{RAGTools.AllTagFilter, RAGTools.AbstractChunkIndex, Vector{T}}} where T&lt;:Union{Regex, AbstractString}"><code>RAGTools.find_tags</code></a></li><li><a href="#RAGTools.find_tags-Union{Tuple{T}, Tuple{RAGTools.NoTagFilter, RAGTools.AbstractChunkIndex, Union{AbstractVector{&lt;:T}, T}}} where T&lt;:Union{Nothing, Regex, AbstractString}"><code>RAGTools.find_tags</code></a></li><li><a href="#RAGTools.generate!-Tuple{RAGTools.AbstractGenerator, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.generate!</code></a></li><li><a href="#RAGTools.get_chunks-Tuple{RAGTools.AbstractChunker, Vector{&lt;:AbstractString}}"><code>RAGTools.get_chunks</code></a></li><li><a href="#RAGTools.get_embeddings-Tuple{RAGTools.BinaryBatchEmbedder, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_embeddings</code></a></li><li><a href="#RAGTools.get_embeddings-Tuple{RAGTools.BatchEmbedder, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_embeddings</code></a></li><li><a href="#RAGTools.get_embeddings-Tuple{RAGTools.BitPackedBatchEmbedder, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_embeddings</code></a></li><li><a href="#RAGTools.get_keywords-Tuple{RAGTools.KeywordsProcessor, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_keywords</code></a></li><li><a href="#RAGTools.get_tags-Tuple{RAGTools.PassthroughTagger, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_tags</code></a></li><li><a href="#RAGTools.get_tags-Tuple{RAGTools.NoTagger, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_tags</code></a></li><li><a href="#RAGTools.get_tags-Tuple{RAGTools.OpenTagger, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_tags</code></a></li><li><a href="#RAGTools.getpropertynested"><code>RAGTools.getpropertynested</code></a></li><li><a href="#RAGTools.hamming_distance-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Integer"><code>RAGTools.hamming_distance</code></a></li><li><a href="#RAGTools.hcat_truncate-Union{Tuple{AbstractVector{&lt;:AbstractMatrix{T}}}, Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, Union{Nothing, Int64}}} where T&lt;:Real"><code>RAGTools.hcat_truncate</code></a></li><li><a href="#RAGTools.load_text-Tuple{RAGTools.AbstractChunker, Any}"><code>RAGTools.load_text</code></a></li><li><a href="#RAGTools.max_bm25_score-Tuple{RAGTools.AbstractDocumentTermMatrix, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.max_bm25_score</code></a></li><li><a href="#RAGTools.merge_kwargs_nested-Tuple{NamedTuple, NamedTuple}"><code>RAGTools.merge_kwargs_nested</code></a></li><li><a href="#RAGTools.pack_bits-Tuple{AbstractMatrix{&lt;:Bool}}"><code>RAGTools.pack_bits</code></a></li><li><a href="#RAGTools.permutation_step!-Tuple{RAGTools.RankGPTResult}"><code>RAGTools.permutation_step!</code></a></li><li><a href="#RAGTools.preprocess_tokens"><code>RAGTools.preprocess_tokens</code></a></li><li><a href="#RAGTools.print_html-Tuple{IO, RAGTools.AbstractAnnotatedNode}"><code>RAGTools.print_html</code></a></li><li><a href="#RAGTools.rank_gpt-Tuple{AbstractVector{&lt;:AbstractString}, AbstractString}"><code>RAGTools.rank_gpt</code></a></li><li><a href="#RAGTools.rank_sliding_window!-Tuple{RAGTools.RankGPTResult}"><code>RAGTools.rank_sliding_window!</code></a></li><li><a href="#RAGTools.receive_permutation!-Tuple{AbstractVector{&lt;:Integer}, AbstractString}"><code>RAGTools.receive_permutation!</code></a></li><li><a href="#RAGTools.reciprocal_rank_fusion-Union{Tuple{T}, Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:T}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:T}}} where T&lt;:Real"><code>RAGTools.reciprocal_rank_fusion</code></a></li><li><a href="#RAGTools.reciprocal_rank_fusion-Tuple"><code>RAGTools.reciprocal_rank_fusion</code></a></li><li><a href="#RAGTools.refine!-Tuple{RAGTools.NoRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.refine!</code></a></li><li><a href="#RAGTools.refine!-Tuple{RAGTools.SimpleRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.refine!</code></a></li><li><a href="#RAGTools.refine!-Tuple{RAGTools.TavilySearchRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.refine!</code></a></li><li><a href="#RAGTools.rephrase-Tuple{RAGTools.NoRephraser, AbstractString}"><code>RAGTools.rephrase</code></a></li><li><a href="#RAGTools.rephrase-Tuple{RAGTools.HyDERephraser, AbstractString}"><code>RAGTools.rephrase</code></a></li><li><a href="#RAGTools.rephrase-Tuple{RAGTools.SimpleRephraser, AbstractString}"><code>RAGTools.rephrase</code></a></li><li><a href="#RAGTools.rerank-Tuple{RAGTools.CohereReranker, RAGTools.AbstractDocumentIndex, AbstractString, RAGTools.AbstractCandidateChunks}"><code>RAGTools.rerank</code></a></li><li><a href="#RAGTools.rerank-Tuple{RAGTools.RankGPTReranker, RAGTools.AbstractDocumentIndex, AbstractString, RAGTools.AbstractCandidateChunks}"><code>RAGTools.rerank</code></a></li><li><a href="#RAGTools.retrieve-Tuple{RAGTools.AbstractRetriever, RAGTools.AbstractDocumentIndex, AbstractString}"><code>RAGTools.retrieve</code></a></li><li><a href="#RAGTools.run_qa_evals-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:RAGTools.QAEvalItem}}"><code>RAGTools.run_qa_evals</code></a></li><li><a href="#RAGTools.run_qa_evals-Tuple{RAGTools.QAEvalItem, RAGResult}"><code>RAGTools.run_qa_evals</code></a></li><li><a href="#RAGTools.score_retrieval_hit-Tuple{AbstractString, Vector{&lt;:AbstractString}}"><code>RAGTools.score_retrieval_hit</code></a></li><li><a href="#RAGTools.score_retrieval_rank-Tuple{AbstractString, Vector{&lt;:AbstractString}}"><code>RAGTools.score_retrieval_rank</code></a></li><li><a href="#RAGTools.score_to_unit_scale-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>RAGTools.score_to_unit_scale</code></a></li><li><a href="#RAGTools.set_node_style!-Tuple{TrigramAnnotater, RAGTools.AnnotatedNode}"><code>RAGTools.set_node_style!</code></a></li><li><a href="#RAGTools.setpropertynested-Tuple{NamedTuple, Vector{Symbol}, Symbol, Any}"><code>RAGTools.setpropertynested</code></a></li><li><a href="#RAGTools.split_into_code_and_sentences-Tuple{Union{SubString{String}, String}}"><code>RAGTools.split_into_code_and_sentences</code></a></li><li><a href="#RAGTools.tags_extract-Tuple{RAGTools.Tag}"><code>RAGTools.tags_extract</code></a></li><li><a href="#RAGTools.tavily_api-Tuple{}"><code>RAGTools.tavily_api</code></a></li><li><a href="#RAGTools.token_with_boundaries-Tuple{Union{Nothing, AbstractString}, AbstractString, Union{Nothing, AbstractString}}"><code>RAGTools.token_with_boundaries</code></a></li><li><a href="#RAGTools.tokenize-Tuple{Union{SubString{String}, String}}"><code>RAGTools.tokenize</code></a></li><li><a href="#RAGTools.translate_positions_to_parent-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.translate_positions_to_parent</code></a></li><li><a href="#RAGTools.translate_positions_to_parent-Tuple{SubChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.translate_positions_to_parent</code></a></li><li><a href="#RAGTools.trigram_support!-Union{Tuple{F2}, Tuple{F1}, Tuple{RAGTools.AnnotatedNode, AbstractVector}, Tuple{RAGTools.AnnotatedNode, AbstractVector, F1}, Tuple{RAGTools.AnnotatedNode, AbstractVector, F1, F2}} where {F1&lt;:Function, F2&lt;:Function}"><code>RAGTools.trigram_support!</code></a></li><li><a href="#RAGTools.trigrams-Tuple{AbstractString}"><code>RAGTools.trigrams</code></a></li><li><a href="#RAGTools.trigrams_hashed-Tuple{AbstractString}"><code>RAGTools.trigrams_hashed</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AbstractCandidateChunks" href="#RAGTools.AbstractCandidateChunks"><code>RAGTools.AbstractCandidateChunks</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCandidateChunks</code></pre><p>Abstract type for storing candidate chunks, ie, references to items in a <code>AbstractChunkIndex</code>.</p><p>Return type from <code>find_closest</code> and <code>find_tags</code> functions.</p><p><strong>Required Fields</strong></p><ul><li><code>index_id::Symbol</code>: the id of the index from which the candidates are drawn</li><li><code>positions::Vector{Int}</code>: the positions of the candidates in the index</li><li><code>scores::Vector{Float32}</code>: the similarity scores of the candidates from the query (higher is better)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rag_interface.jl#L166-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AbstractChunkIndex" href="#RAGTools.AbstractChunkIndex"><code>RAGTools.AbstractChunkIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractChunkIndex &lt;: AbstractDocumentIndex</code></pre><p>Main abstract type for storing document chunks and their embeddings. It also stores tags and sources for each chunk.</p><p><strong>Required Fields</strong></p><ul><li><code>id::Symbol</code>: unique identifier of each index (to ensure we&#39;re using the right index with <code>CandidateChunks</code>)</li><li><code>chunks::Vector{&lt;:AbstractString}</code>: underlying document chunks / snippets</li><li><code>embeddings::Union{Nothing, Matrix{&lt;:Real}}</code>: for semantic search</li><li><code>tags::Union{Nothing, AbstractMatrix{&lt;:Bool}}</code>: for exact search, filtering, etc. This is often a sparse matrix indicating which chunks have the given <code>tag</code> (see <code>tag_vocab</code> for the position lookup)</li><li><code>tags_vocab::Union{Nothing, Vector{&lt;:AbstractString}}</code>: vocabulary for the <code>tags</code> matrix (each column in <code>tags</code> is one item in <code>tags_vocab</code> and rows are the chunks)</li><li><code>sources::Vector{&lt;:AbstractString}</code>: sources of the chunks</li><li><code>extras::Union{Nothing, AbstractVector}</code>: additional data, eg, metadata, source code, etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rag_interface.jl#L148-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AbstractGenerator" href="#RAGTools.AbstractGenerator"><code>RAGTools.AbstractGenerator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractGenerator &lt;: AbstractGenerationMethod</code></pre><p>Abstract type for generating an answer with <code>generate!</code> (use to change the process / return type of <code>generate</code>).</p><p><strong>Required Fields</strong></p><ul><li><code>contexter::AbstractContextBuilder</code>: the context building method, dispatching `build_context!</li><li><code>answerer::AbstractAnswerer</code>: the answer generation method, dispatching <code>answer!</code></li><li><code>refiner::AbstractRefiner</code>: the answer refining method, dispatching <code>refine!</code></li><li><code>postprocessor::AbstractPostprocessor</code>: the postprocessing method, dispatching <code>postprocess!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rag_interface.jl#L213-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AbstractIndexBuilder" href="#RAGTools.AbstractIndexBuilder"><code>RAGTools.AbstractIndexBuilder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractIndexBuilder</code></pre><p>Abstract type for building an index with <code>build_index</code> (use to change the process / return type of <code>build_index</code>).</p><p><strong>Required Fields</strong></p><ul><li><code>chunker::AbstractChunker</code>: the chunking method, dispatching <code>get_chunks</code></li><li><code>embedder::AbstractEmbedder</code>: the embedding method, dispatching <code>get_embeddings</code></li><li><code>tagger::AbstractTagger</code>: the tagging method, dispatching <code>get_tags</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rag_interface.jl#L117-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AbstractMultiIndex" href="#RAGTools.AbstractMultiIndex"><code>RAGTools.AbstractMultiIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractMultiIndex &lt;: AbstractDocumentIndex</code></pre><p>Experimental abstract type for storing multiple document indexes. Not yet implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rag_interface.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AbstractRetriever" href="#RAGTools.AbstractRetriever"><code>RAGTools.AbstractRetriever</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRetriever &lt;: AbstractRetrievalMethod</code></pre><p>Abstract type for retrieving chunks from an index with <code>retrieve</code> (use to change the process / return type of <code>retrieve</code>).</p><p><strong>Required Fields</strong></p><ul><li><code>rephraser::AbstractRephraser</code>: the rephrasing method, dispatching <code>rephrase</code></li><li><code>finder::AbstractSimilarityFinder</code>: the similarity search method, dispatching <code>find_closest</code></li><li><code>filter::AbstractTagFilter</code>: the tag matching method, dispatching <code>find_tags</code></li><li><code>reranker::AbstractReranker</code>: the reranking method, dispatching <code>rerank</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rag_interface.jl#L184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AdvancedGenerator" href="#RAGTools.AdvancedGenerator"><code>RAGTools.AdvancedGenerator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvancedGenerator &lt;: AbstractGenerator</code></pre><p>Default implementation for <code>generate!</code>. It simply enumerates context snippets and runs <code>aigenerate</code> (no refinement).</p><p>It uses <code>ContextEnumerator</code>, <code>SimpleAnswerer</code>, <code>SimpleRefiner</code>, and <code>NoPostprocessor</code> as default <code>contexter</code>, <code>answerer</code>, <code>refiner</code>, and <code>postprocessor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L381-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AdvancedRetriever" href="#RAGTools.AdvancedRetriever"><code>RAGTools.AdvancedRetriever</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdvancedRetriever &lt;: AbstractRetriever</code></pre><p>Dispatch for <code>retrieve</code> with advanced retrieval methods to improve result quality. Compared to SimpleRetriever, it adds rephrasing the query and reranking the results.</p><p><strong>Fields</strong></p><ul><li><code>rephraser::AbstractRephraser</code>: the rephrasing method, dispatching <code>rephrase</code> - uses <code>HyDERephraser</code></li><li><code>embedder::AbstractEmbedder</code>: the embedding method, dispatching <code>get_embeddings</code> (see Preparation Stage for more details) - uses <code>BatchEmbedder</code></li><li><code>processor::AbstractProcessor</code>: the processor method, dispatching <code>get_keywords</code> (see Preparation Stage for more details) - uses <code>NoProcessor</code></li><li><code>finder::AbstractSimilarityFinder</code>: the similarity search method, dispatching <code>find_closest</code> - uses <code>CosineSimilarity</code></li><li><code>tagger::AbstractTagger</code>: the tag generating method, dispatching <code>get_tags</code> (see Preparation Stage for more details) - uses <code>NoTagger</code></li><li><code>filter::AbstractTagFilter</code>: the tag matching method, dispatching <code>find_tags</code> - uses <code>NoTagFilter</code></li><li><code>reranker::AbstractReranker</code>: the reranking method, dispatching <code>rerank</code> - uses <code>CohereReranker</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L922-L936">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AllTagFilter" href="#RAGTools.AllTagFilter"><code>RAGTools.AllTagFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AllTagFilter &lt;: AbstractTagFilter</code></pre><p>Finds the chunks that have ALL OF the specified tag(s). A method for <code>find_tags</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AnnotatedNode" href="#RAGTools.AnnotatedNode"><code>RAGTools.AnnotatedNode</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AnnotatedNode{T}  &lt;: AbstractAnnotatedNode</code></pre><p>A node to add annotations to the generated answer in <code>airag</code></p><p>Annotations can be: sources, scores, whether its supported or not by the context, etc.</p><p><strong>Fields</strong></p><ul><li><code>group_id::Int</code>: Unique identifier for the same group of nodes (eg, different lines of the same code block)</li><li><code>parent::Union{AnnotatedNode, Nothing}</code>: Parent node that current node was built on</li><li><code>children::Vector{AnnotatedNode}</code>: Children nodes</li><li>`score::</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.AnyTagFilter" href="#RAGTools.AnyTagFilter"><code>RAGTools.AnyTagFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AnyTagFilter &lt;: AbstractTagFilter</code></pre><p>Finds the chunks that have ANY OF the specified tag(s). A method for <code>find_tags</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.BM25Similarity" href="#RAGTools.BM25Similarity"><code>RAGTools.BM25Similarity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BM25Similarity &lt;: AbstractSimilarityFinder</code></pre><p>Finds the closest chunks to a query embedding by measuring the BM25 similarity between the query and the chunks&#39; embeddings in binary form. A method for <code>find_closest</code>.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Okapi_BM25">Wikipedia: BM25</a>. Implementation follows: <a href="https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/">The Next Generation of Lucene Relevance</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L61-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.BatchEmbedder" href="#RAGTools.BatchEmbedder"><code>RAGTools.BatchEmbedder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BatchEmbedder &lt;: AbstractEmbedder</code></pre><p>Default embedder for <code>get_embeddings</code> functions. It passes individual documents to be embedded in chunks to <code>aiembed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.BinaryBatchEmbedder" href="#RAGTools.BinaryBatchEmbedder"><code>RAGTools.BinaryBatchEmbedder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BinaryBatchEmbedder &lt;: AbstractEmbedder</code></pre><p>Same as <code>BatchEmbedder</code> but reduces the embeddings matrix to a binary form (eg, <code>BitMatrix</code>). Defines a method for <code>get_embeddings</code>.</p><p>Reference: <a href="https://huggingface.co/blog/embedding-quantization#binary-quantization-in-vector-databases">HuggingFace: Embedding Quantization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.BinaryCosineSimilarity" href="#RAGTools.BinaryCosineSimilarity"><code>RAGTools.BinaryCosineSimilarity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BinaryCosineSimilarity &lt;: AbstractSimilarityFinder</code></pre><p>Finds the closest chunks to a query embedding by measuring the Hamming distance AND cosine similarity between the query and the chunks&#39; embeddings in binary form. A method for <code>find_closest</code>.</p><p>It follows the two-pass approach:</p><ul><li>First pass: Hamming distance in binary form to get the <code>top_k * rescore_multiplier</code> (ie, more than top_k) candidates.</li><li>Second pass: Rescore the candidates with float embeddings and return the top_k.</li></ul><p>Reference: <a href="https://huggingface.co/blog/embedding-quantization#binary-quantization-in-vector-databases">HuggingFace: Embedding Quantization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.BitPackedBatchEmbedder" href="#RAGTools.BitPackedBatchEmbedder"><code>RAGTools.BitPackedBatchEmbedder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BitPackedBatchEmbedder &lt;: AbstractEmbedder</code></pre><p>Same as <code>BatchEmbedder</code> but reduces the embeddings matrix to a binary form packed in UInt64 (eg, <code>BitMatrix.chunks</code>). Defines a method for <code>get_embeddings</code>.</p><p>See also utilities <code>pack_bits</code> and <code>unpack_bits</code> to move between packed/non-packed binary forms.</p><p>Reference: <a href="https://huggingface.co/blog/embedding-quantization#binary-quantization-in-vector-databases">HuggingFace: Embedding Quantization</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.BitPackedCosineSimilarity" href="#RAGTools.BitPackedCosineSimilarity"><code>RAGTools.BitPackedCosineSimilarity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BitPackedCosineSimilarity &lt;: AbstractSimilarityFinder</code></pre><p>Finds the closest chunks to a query embedding by measuring the Hamming distance AND cosine similarity between the query and the chunks&#39; embeddings in binary form. A method for <code>find_closest</code>.</p><p>The difference to <code>BinaryCosineSimilarity</code> is that the binary values are packed into UInt64, which is more efficient.</p><p>Reference: <a href="https://huggingface.co/blog/embedding-quantization#binary-quantization-in-vector-databases">HuggingFace: Embedding Quantization</a>. Implementation of <code>hamming_distance</code> is based on <a href="https://github.com/domluna/tinyrag/blob/main/README.md">TinyRAG</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L49-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.CandidateChunks" href="#RAGTools.CandidateChunks"><code>RAGTools.CandidateChunks</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CandidateChunks</code></pre><p>A struct for storing references to chunks in the given index (identified by <code>index_id</code>) called <code>positions</code> and <code>scores</code> holding the strength of similarity (=1 is the highest, most similar). It&#39;s the result of the retrieval stage of RAG.</p><p><strong>Fields</strong></p><ul><li><code>index_id::Symbol</code>: the id of the index from which the candidates are drawn</li><li><code>positions::Vector{Int}</code>: the positions of the candidates in the index (ie, <code>5</code> refers to the 5th chunk in the index - <code>chunks(index)[5]</code>)</li><li><code>scores::Vector{Float32}</code>: the similarity scores of the candidates from the query (higher is better)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L520-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.ChunkEmbeddingsIndex" href="#RAGTools.ChunkEmbeddingsIndex"><code>RAGTools.ChunkEmbeddingsIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChunkEmbeddingsIndex</code></pre><p>Main struct for storing document chunks and their embeddings. It also stores tags and sources for each chunk.</p><p>Previously, this struct was called <code>ChunkIndex</code>.</p><p><strong>Fields</strong></p><ul><li><code>id::Symbol</code>: unique identifier of each index (to ensure we&#39;re using the right index with <code>CandidateChunks</code>)</li><li><code>chunks::Vector{&lt;:AbstractString}</code>: underlying document chunks / snippets</li><li><code>embeddings::Union{Nothing, Matrix{&lt;:Real}}</code>: for semantic search</li><li><code>tags::Union{Nothing, AbstractMatrix{&lt;:Bool}}</code>: for exact search, filtering, etc. This is often a sparse matrix indicating which chunks have the given <code>tag</code> (see <code>tag_vocab</code> for the position lookup)</li><li><code>tags_vocab::Union{Nothing, Vector{&lt;:AbstractString}}</code>: vocabulary for the <code>tags</code> matrix (each column in <code>tags</code> is one item in <code>tags_vocab</code> and rows are the chunks)</li><li><code>sources::Vector{&lt;:AbstractString}</code>: sources of the chunks</li><li><code>extras::Union{Nothing, AbstractVector}</code>: additional data, eg, metadata, source code, etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L95-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.ChunkKeywordsIndex" href="#RAGTools.ChunkKeywordsIndex"><code>RAGTools.ChunkKeywordsIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChunkKeywordsIndex</code></pre><p>Struct for storing chunks of text and associated keywords for BM25 similarity search.</p><p><strong>Fields</strong></p><ul><li><code>id::Symbol</code>: unique identifier of each index (to ensure we&#39;re using the right index with <code>CandidateChunks</code>)</li><li><code>chunks::Vector{&lt;:AbstractString}</code>: underlying document chunks / snippets</li><li><code>chunkdata::Union{Nothing, AbstractMatrix{&lt;:Real}}</code>: for similarity search, assumed to be <code>DocumentTermMatrix</code></li><li><code>tags::Union{Nothing, AbstractMatrix{&lt;:Bool}}</code>: for exact search, filtering, etc. This is often a sparse matrix indicating which chunks have the given <code>tag</code> (see <code>tag_vocab</code> for the position lookup)</li><li><code>tags_vocab::Union{Nothing, Vector{&lt;:AbstractString}}</code>: vocabulary for the <code>tags</code> matrix (each column in <code>tags</code> is one item in <code>tags_vocab</code> and rows are the chunks)</li><li><code>sources::Vector{&lt;:AbstractString}</code>: sources of the chunks</li><li><code>extras::Union{Nothing, AbstractVector}</code>: additional data, eg, metadata, source code, etc.</li></ul><p><strong>Example</strong></p><p>We can easily create a keywords-based index from a standard embeddings-based index.</p><pre><code class="language-julia hljs">
# Let&#39;s assume we have a standard embeddings-based index
index = build_index(SimpleIndexer(), texts; chunker_kwargs = (; max_length=10))

# Creating an additional index for keyword-based search (BM25), is as simple as
index_keywords = ChunkKeywordsIndex(index)

# We can immediately create a MultiIndex (a hybrid index holding both indices)
multi_index = MultiIndex([index, index_keywords])
</code></pre><p>You can also build the index via build_index</p><pre><code class="language-julia hljs"># given some sentences and sources
index_keywords = build_index(KeywordsIndexer(), sentences; chunker_kwargs=(; sources))

# Retrive closest chunks with
retriever = SimpleBM25Retriever()
result = retrieve(retriever, index_keywords, &quot;What are the best practices for parallel computing in Julia?&quot;)
result.context</code></pre><p>If you want to use airag, don&#39;t forget to specify the config to make sure keywords are processed (ie, tokenized)  and that BM25 is used for searching candidates</p><pre><code class="language-julia hljs">cfg = RAGConfig(; retriever = SimpleBM25Retriever());
airag(cfg, index_keywords;
    question = &quot;What are the best practices for parallel computing in Julia?&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L248-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.ChunkKeywordsIndex-Tuple{RAGTools.AbstractProcessor, ChunkEmbeddingsIndex}" href="#RAGTools.ChunkKeywordsIndex-Tuple{RAGTools.AbstractProcessor, ChunkEmbeddingsIndex}"><code>RAGTools.ChunkKeywordsIndex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChunkKeywordsIndex(
    [processor::AbstractProcessor=KeywordsProcessor(),] index::ChunkEmbeddingsIndex; verbose::Int = 1,
    index_id = gensym(&quot;ChunkKeywordsIndex&quot;), processor_kwargs...)</code></pre><p>Convenience method to quickly create a <code>ChunkKeywordsIndex</code> from an existing <code>ChunkEmbeddingsIndex</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">
# Let&#39;s assume we have a standard embeddings-based index
index = build_index(SimpleIndexer(), texts; chunker_kwargs = (; max_length=10))

# Creating an additional index for keyword-based search (BM25), is as simple as
index_keywords = ChunkKeywordsIndex(index)

# We can immediately create a MultiIndex (a hybrid index holding both indices)
multi_index = MultiIndex([index, index_keywords])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L765-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.CohereReranker" href="#RAGTools.CohereReranker"><code>RAGTools.CohereReranker</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CohereReranker &lt;: AbstractReranker</code></pre><p>Rerank strategy using the Cohere Rerank API. Requires an API key. A method for <code>rerank</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L623-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.ContextEnumerator" href="#RAGTools.ContextEnumerator"><code>RAGTools.ContextEnumerator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ContextEnumerator &lt;: AbstractContextBuilder</code></pre><p>Default method for <code>build_context!</code> method. It simply enumerates the context snippets around each position in <code>candidates</code>. When possibly, it will add surrounding chunks (from the same source).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.CosineSimilarity" href="#RAGTools.CosineSimilarity"><code>RAGTools.CosineSimilarity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CosineSimilarity &lt;: AbstractSimilarityFinder</code></pre><p>Finds the closest chunks to a query embedding by measuring the cosine similarity between the query and the chunks&#39; embeddings. A method for <code>find_closest</code> (see the docstring for more details and usage example).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.DocumentTermMatrix" href="#RAGTools.DocumentTermMatrix"><code>RAGTools.DocumentTermMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DocumentTermMatrix{T&lt;:AbstractString}</code></pre><p>A sparse matrix of term frequencies and document lengths to allow calculation of BM25 similarity scores.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.FileChunker" href="#RAGTools.FileChunker"><code>RAGTools.FileChunker</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FileChunker &lt;: AbstractChunker</code></pre><p>Chunker when you provide file paths to <code>get_chunks</code> functions.</p><p>Ie, the inputs will be validated first (eg, file exists, etc) and then read into memory.</p><p>Set as default chunker in <code>get_chunks</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.FlashRanker" href="#RAGTools.FlashRanker"><code>RAGTools.FlashRanker</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FlashRanker &lt;: AbstractReranker</code></pre><p>Rerank strategy using the package FlashRank.jl and local models. A method for <code>rerank</code>.</p><p>You must first import the FlashRank.jl package. To automatically download any required models, set your  <code>ENV[&quot;DATADEPS_ALWAYS_ACCEPT&quot;] = true</code> (see <a href="https://www.oxinabox.net/DataDeps.jl/dev/z10-for-end-users/">DataDeps</a> for more details).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using FlashRank

# Wrap the model to be a valid Ranker recognized by RAGTools
# It will be provided to the airag/rerank function to avoid instantiating it on every call
reranker = FlashRank.RankerModel(:mini) |&gt; FlashRanker
# You can choose :tiny or :mini

## Apply to the pipeline configuration, eg, 
cfg = RAGConfig(; retriever = AdvancedRetriever(; reranker))

# Ask a question (assumes you have some `index`)
question = &quot;What are the best practices for parallel computing in Julia?&quot;
result = airag(cfg, index; question, return_all = true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L630-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.HTMLStyler" href="#RAGTools.HTMLStyler"><code>RAGTools.HTMLStyler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HTMLStyler</code></pre><p>Defines styling via classes (attribute <code>class</code>) and styles (attribute <code>style</code>) for HTML formatting of <code>AbstractAnnotatedNode</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.HyDERephraser" href="#RAGTools.HyDERephraser"><code>RAGTools.HyDERephraser</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HyDERephraser &lt;: AbstractRephraser</code></pre><p>Rephraser implemented using the provided AI Template (eg, <code>...</code>) and standard chat model. A method for <code>rephrase</code>.</p><p>It uses a prompt-based rephrasing method called HyDE (Hypothetical Document Embedding), where instead of looking for an embedding of the question,  we look for the documents most similar to a synthetic passage that <em>would be</em> a good answer to our question.</p><p>Reference: <a href="https://arxiv.org/abs/2212.10496">Arxiv paper</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.JudgeAllScores" href="#RAGTools.JudgeAllScores"><code>RAGTools.JudgeAllScores</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>final_rating</code> is the average of all scoring criteria. Explain the <code>final_rating</code> in <code>rationale</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/evaluation.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.JudgeRating" href="#RAGTools.JudgeRating"><code>RAGTools.JudgeRating</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Provide the <code>final_rating</code> between 1-5. Provide the rationale for it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/evaluation.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.KeywordsIndexer" href="#RAGTools.KeywordsIndexer"><code>RAGTools.KeywordsIndexer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KeywordsIndexer &lt;: AbstractIndexBuilder</code></pre><p>Keyword-based index (BM25) to be returned by <code>build_index</code>.</p><p>It uses <code>TextChunker</code>, <code>KeywordsProcessor</code>, and <code>NoTagger</code> as default chunker, processor, and tagger.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.KeywordsProcessor" href="#RAGTools.KeywordsProcessor"><code>RAGTools.KeywordsProcessor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KeywordsProcessor &lt;: AbstractProcessor</code></pre><p>Default keywords processor for <code>get_keywords</code> functions. It normalizes the documents, tokenizes them and builds a <code>DocumentTermMatrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.MultiCandidateChunks" href="#RAGTools.MultiCandidateChunks"><code>RAGTools.MultiCandidateChunks</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiCandidateChunks</code></pre><p>A struct for storing references to multiple sets of chunks across different indices. Each set of chunks is identified by an <code>index_id</code> in <code>index_ids</code>, with corresponding <code>positions</code> in the index and <code>scores</code> indicating the strength of similarity.</p><p>This struct is useful for scenarios where candidates are drawn from multiple indices, and there is a need to keep track of which candidates came from which index.</p><p><strong>Fields</strong></p><ul><li><code>index_ids::Vector{Symbol}</code>: the ids of the indices from which the candidates are drawn</li><li><code>positions::Vector{TP}</code>: the positions of the candidates in their respective indices</li><li><code>scores::Vector{TD}</code>: the similarity scores of the candidates from the query</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L563-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.MultiFinder" href="#RAGTools.MultiFinder"><code>RAGTools.MultiFinder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiFinder &lt;: AbstractSimilarityFinder</code></pre><p>Composite finder for <code>MultiIndex</code> where we want to set multiple finders for each index. A method for <code>find_closest</code>. Positions correspond to <code>indexes(::MultiIndex)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.MultiIndex" href="#RAGTools.MultiIndex"><code>RAGTools.MultiIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiIndex</code></pre><p>Composite index that stores multiple ChunkIndex objects and their embeddings.</p><p><strong>Fields</strong></p><ul><li><code>id::Symbol</code>: unique identifier of each index (to ensure we&#39;re using the right index with <code>CandidateChunks</code>)</li><li><code>indexes::Vector{&lt;:AbstractChunkIndex}</code>: the indexes to be combined</li></ul><p>Use accesor <code>indexes</code> to access the individual indexes.</p><p><strong>Examples</strong></p><p>We can create a <code>MultiIndex</code> from a vector of <code>AbstractChunkIndex</code> objects.</p><pre><code class="language-julia hljs">index = build_index(SimpleIndexer(), texts; chunker_kwargs = (; sources))
index_keywords = ChunkKeywordsIndex(index) # same chunks as above but adds BM25 instead of embeddings

multi_index = MultiIndex([index, index_keywords])</code></pre><p>To use <code>airag</code> with different types of indices, we need to specify how to find the closest items for each index</p><pre><code class="language-julia hljs"># Cosine similarity for embeddings and BM25 for keywords, same order as indexes in MultiIndex
finder = RT.MultiFinder([RT.CosineSimilarity(), RT.BM25Similarity()])

# Notice that we add `processor` to make sure keywords are processed (ie, tokenized) as well
cfg = RAGConfig(; retriever = SimpleRetriever(; processor = RT.KeywordsProcessor(), finder))

# Ask questions
msg = airag(cfg, multi_index; question = &quot;What are the best practices for parallel computing in Julia?&quot;)
pprint(msg) # prettify the answer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L330-L364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoEmbedder" href="#RAGTools.NoEmbedder"><code>RAGTools.NoEmbedder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoEmbedder &lt;: AbstractEmbedder</code></pre><p>No-op embedder for <code>get_embeddings</code> functions. It returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoPostprocessor" href="#RAGTools.NoPostprocessor"><code>RAGTools.NoPostprocessor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoPostprocessor &lt;: AbstractPostprocessor</code></pre><p>Default method for <code>postprocess!</code> method. A passthrough option that returns the <code>result</code> without any changes.</p><p>Overload this method to add custom postprocessing steps, eg, logging, saving conversations to disk, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L347-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoProcessor" href="#RAGTools.NoProcessor"><code>RAGTools.NoProcessor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoProcessor &lt;: AbstractProcessor</code></pre><p>No-op processor for <code>get_keywords</code> functions. It returns the inputs as is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoRefiner" href="#RAGTools.NoRefiner"><code>RAGTools.NoRefiner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoRefiner &lt;: AbstractRefiner</code></pre><p>Default method for <code>refine!</code> method. A passthrough option that returns the <code>result.answer</code> without any changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoRephraser" href="#RAGTools.NoRephraser"><code>RAGTools.NoRephraser</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoRephraser &lt;: AbstractRephraser</code></pre><p>No-op implementation for <code>rephrase</code>, which simply passes the question through.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoReranker" href="#RAGTools.NoReranker"><code>RAGTools.NoReranker</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoReranker &lt;: AbstractReranker</code></pre><p>No-op implementation for <code>rerank</code>, which simply passes the candidate chunks through.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L616-L620">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoTagFilter" href="#RAGTools.NoTagFilter"><code>RAGTools.NoTagFilter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoTagFilter &lt;: AbstractTagFilter</code></pre><p>No-op implementation for <code>find_tags</code>, which simply returns all chunks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.NoTagger" href="#RAGTools.NoTagger"><code>RAGTools.NoTagger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoTagger &lt;: AbstractTagger</code></pre><p>No-op tagger for <code>get_tags</code> functions. It returns (<code>nothing</code>, <code>nothing</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.OpenTagger" href="#RAGTools.OpenTagger"><code>RAGTools.OpenTagger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpenTagger &lt;: AbstractTagger</code></pre><p>Tagger for <code>get_tags</code> functions, which generates possible tags for each chunk via <code>aiextract</code>.  You can customize it via prompt template (default: <code>:RAGExtractMetadataShort</code>), but it&#39;s quite open-ended (ie, AI decides the possible tags).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L93-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.PassthroughTagger" href="#RAGTools.PassthroughTagger"><code>RAGTools.PassthroughTagger</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PassthroughTagger &lt;: AbstractTagger</code></pre><p>Tagger for <code>get_tags</code> functions, which passes <code>tags</code> directly as Vector of Vectors of strings (ie, <code>tags[i]</code> is the tags for <code>docs[i]</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.RAGConfig" href="#RAGTools.RAGConfig"><code>RAGTools.RAGConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RAGConfig &lt;: AbstractRAGConfig</code></pre><p>Default configuration for RAG. It uses <code>SimpleIndexer</code>, <code>SimpleRetriever</code>, and <code>SimpleGenerator</code> as default components. Provided as the first argument in <code>airag</code>.</p><p>To customize the components, replace corresponding fields for each step of the RAG pipeline (eg, use <code>subtypes(AbstractIndexBuilder)</code> to find the available options).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L511-L517">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.RAGResult" href="#RAGTools.RAGResult"><code>RAGTools.RAGResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RAGResult</code></pre><p>A struct for debugging RAG answers. It contains the question, answer, context, and the candidate chunks at each step of the RAG pipeline.</p><p>Think of the flow as <code>question</code> -&gt; <code>rephrased_questions</code> -&gt; <code>answer</code> -&gt; <code>final_answer</code> with the context and candidate chunks helping along the way.</p><p><strong>Fields</strong></p><ul><li><code>question::AbstractString</code>: the original question</li><li><code>rephrased_questions::Vector{&lt;:AbstractString}</code>: a vector of rephrased questions (eg, HyDe, Multihop, etc.)</li><li><code>answer::AbstractString</code>: the generated answer</li><li><code>final_answer::AbstractString</code>: the refined final answer (eg, after CorrectiveRAG), also considered the FINAL answer (it must be always available)</li><li><code>context::Vector{&lt;:AbstractString}</code>: the context used for retrieval (ie, the vector of chunks and their surrounding window if applicable)</li><li><code>sources::Vector{&lt;:AbstractString}</code>: the sources of the context (for the original matched chunks)</li><li><code>emb_candidates::CandidateChunks</code>: the candidate chunks from the embedding index (from <code>find_closest</code>)</li><li><code>tag_candidates::Union{Nothing, CandidateChunks}</code>: the candidate chunks from the tag index (from <code>find_tags</code>)</li><li><code>filtered_candidates::CandidateChunks</code>: the filtered candidate chunks (intersection of <code>emb_candidates</code> and <code>tag_candidates</code>)</li><li><code>reranked_candidates::CandidateChunks</code>: the reranked candidate chunks (from <code>rerank</code>)</li><li><code>conversations::Dict{Symbol,Vector{&lt;:AbstractMessage}}</code>: the conversation history for AI steps of the RAG pipeline, use keys that correspond to the function names, eg, <code>:answer</code> or <code>:refine</code></li></ul><p>See also: <code>pprint</code> (pretty printing), <code>annotate_support</code> (for annotating the answer)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L945-L966">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.RankGPTReranker" href="#RAGTools.RankGPTReranker"><code>RAGTools.RankGPTReranker</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RankGPTReranker &lt;: AbstractReranker</code></pre><p>Rerank strategy using the RankGPT algorithm (calling LLMs). A method for <code>rerank</code>.</p><p><strong>Reference</strong></p><p>[1] <a href="https://arxiv.org/abs/2304.09542">Is ChatGPT Good at Search? Investigating Large Language Models as Re-Ranking Agents by W. Sun et al.</a> [2] <a href="https://github.com/sunnweiwei/RankGPT">RankGPT Github</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L660-L668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.RankGPTResult" href="#RAGTools.RankGPTResult"><code>RAGTools.RankGPTResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RankGPTResult</code></pre><p>Results from the RankGPT algorithm.</p><p><strong>Fields</strong></p><ul><li><code>question::String</code>: The question that was asked.</li><li><code>chunks::AbstractVector{T}</code>: The chunks that were ranked (=context).</li><li><code>positions::Vector{Int}</code>: The ranking of the chunks (referring to the <code>chunks</code>).</li><li><code>elapsed::Float64</code>: The time it took to rank the chunks.</li><li><code>cost::Float64</code>: The cumulative cost of the ranking.</li><li><code>tokens::Int</code>: The cumulative number of tokens used in the ranking.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rank_gpt.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SimpleAnswerer" href="#RAGTools.SimpleAnswerer"><code>RAGTools.SimpleAnswerer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleAnswerer &lt;: AbstractAnswerer</code></pre><p>Default method for <code>answer!</code> method. Generates an answer using the <code>aigenerate</code> function with the provided context and question.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SimpleBM25Retriever" href="#RAGTools.SimpleBM25Retriever"><code>RAGTools.SimpleBM25Retriever</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleBM25Retriever &lt;: AbstractRetriever</code></pre><p>Keyword-based implementation for <code>retrieve</code>. It does a simple similarity search via <code>BM25Similarity</code> and returns the results.</p><p>Make sure to use consistent <code>processor</code> and <code>tagger</code> with the Preparation Stage (<code>build_index</code>)!</p><p><strong>Fields</strong></p><ul><li><code>rephraser::AbstractRephraser</code>: the rephrasing method, dispatching <code>rephrase</code> - uses <code>NoRephraser</code></li><li><code>embedder::AbstractEmbedder</code>: the embedding method, dispatching <code>get_embeddings</code> (see Preparation Stage for more details) - uses <code>NoEmbedder</code></li><li><code>processor::AbstractProcessor</code>: the processor method, dispatching <code>get_keywords</code> (see Preparation Stage for more details) - uses <code>KeywordsProcessor</code></li><li><code>finder::AbstractSimilarityFinder</code>: the similarity search method, dispatching <code>find_closest</code> - uses <code>CosineSimilarity</code></li><li><code>tagger::AbstractTagger</code>: the tag generating method, dispatching <code>get_tags</code> (see Preparation Stage for more details) - uses <code>NoTagger</code></li><li><code>filter::AbstractTagFilter</code>: the tag matching method, dispatching <code>find_tags</code> - uses <code>NoTagFilter</code></li><li><code>reranker::AbstractReranker</code>: the reranking method, dispatching <code>rerank</code> - uses <code>NoReranker</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L896-L911">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SimpleGenerator" href="#RAGTools.SimpleGenerator"><code>RAGTools.SimpleGenerator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleGenerator &lt;: AbstractGenerator</code></pre><p>Default implementation for <code>generate</code>. It simply enumerates context snippets and runs <code>aigenerate</code> (no refinement).</p><p>It uses <code>ContextEnumerator</code>, <code>SimpleAnswerer</code>, <code>NoRefiner</code>, and <code>NoPostprocessor</code> as default <code>contexter</code>, <code>answerer</code>, <code>refiner</code>, and <code>postprocessor</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L367-L373">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SimpleIndexer" href="#RAGTools.SimpleIndexer"><code>RAGTools.SimpleIndexer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleIndexer &lt;: AbstractIndexBuilder</code></pre><p>Default implementation for <code>build_index</code>.</p><p>It uses <code>TextChunker</code>, <code>BatchEmbedder</code>, and <code>NoTagger</code> as default chunker, embedder, and tagger.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SimpleRefiner" href="#RAGTools.SimpleRefiner"><code>RAGTools.SimpleRefiner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleRefiner &lt;: AbstractRefiner</code></pre><p>Refines the answer using the same context previously provided via the provided prompt template. A method for <code>refine!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SimpleRephraser" href="#RAGTools.SimpleRephraser"><code>RAGTools.SimpleRephraser</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleRephraser &lt;: AbstractRephraser</code></pre><p>Rephraser implemented using the provided AI Template (eg, <code>...</code>) and standard chat model. A method for <code>rephrase</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SimpleRetriever" href="#RAGTools.SimpleRetriever"><code>RAGTools.SimpleRetriever</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleRetriever &lt;: AbstractRetriever</code></pre><p>Default implementation for <code>retrieve</code> function. It does a simple similarity search via <code>CosineSimilarity</code> and returns the results.</p><p>Make sure to use consistent <code>embedder</code> and <code>tagger</code> with the Preparation Stage (<code>build_index</code>)!</p><p><strong>Fields</strong></p><ul><li><code>rephraser::AbstractRephraser</code>: the rephrasing method, dispatching <code>rephrase</code> - uses <code>NoRephraser</code></li><li><code>embedder::AbstractEmbedder</code>: the embedding method, dispatching <code>get_embeddings</code> (see Preparation Stage for more details) - uses <code>BatchEmbedder</code></li><li><code>processor::AbstractProcessor</code>: the processor method, dispatching <code>get_keywords</code> (see Preparation Stage for more details) - uses <code>NoProcessor</code></li><li><code>finder::AbstractSimilarityFinder</code>: the similarity search method, dispatching <code>find_closest</code> - uses <code>CosineSimilarity</code></li><li><code>tagger::AbstractTagger</code>: the tag generating method, dispatching <code>get_tags</code> (see Preparation Stage for more details) - uses <code>NoTagger</code></li><li><code>filter::AbstractTagFilter</code>: the tag matching method, dispatching <code>find_tags</code> - uses <code>NoTagFilter</code></li><li><code>reranker::AbstractReranker</code>: the reranking method, dispatching <code>rerank</code> - uses <code>NoReranker</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L870-L885">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.Styler" href="#RAGTools.Styler"><code>RAGTools.Styler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Styler</code></pre><p>Defines styling keywords for <code>printstyled</code> for each <code>AbstractAnnotatedNode</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SubChunkIndex" href="#RAGTools.SubChunkIndex"><code>RAGTools.SubChunkIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SubChunkIndex</code></pre><p>A view of the parent index with respect to the <code>chunks</code> (and chunk-aligned fields). All methods and accessors working for <code>AbstractChunkIndex</code> also work for <code>SubChunkIndex</code>. It does not yet work for <code>MultiIndex</code>.</p><p><strong>Fields</strong></p><ul><li><code>parent::AbstractChunkIndex</code>: the parent index from which the chunks are drawn (always the original index, never a view)</li><li><code>positions::Vector{Int}</code>: the positions of the chunks in the parent index (always refers to original PARENT index, even if we create a view of the view)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">cc = CandidateChunks(index.id, 1:10)
sub_index = @view(index[cc])</code></pre><p>You can use <code>SubChunkIndex</code> to access chunks or sources (and other fields) from a parent index, eg,</p><pre><code class="language-julia hljs">RT.chunks(sub_index)
RT.sources(sub_index)
RT.chunkdata(sub_index) # slice of embeddings
RT.embeddings(sub_index) # slice of embeddings
RT.tags(sub_index) # slice of tags
RT.tags_vocab(sub_index) # unchanged, identical to parent version
RT.extras(sub_index) # slice of extras</code></pre><p>Access the parent index that the <code>positions</code> correspond to</p><pre><code class="language-julia hljs">parent(sub_index)
RT.positions(sub_index)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L399-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.SubDocumentTermMatrix" href="#RAGTools.SubDocumentTermMatrix"><code>RAGTools.SubDocumentTermMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A partial view of a DocumentTermMatrix, <code>tf</code> is MATERIALIZED for performance and fewer allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.TavilySearchRefiner" href="#RAGTools.TavilySearchRefiner"><code>RAGTools.TavilySearchRefiner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TavilySearchRefiner &lt;: AbstractRefiner</code></pre><p>Refines the answer by executing a web search using the Tavily API. This method aims to enhance the answer&#39;s accuracy and relevance by incorporating information retrieved from the web. A method for <code>refine!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.TextChunker" href="#RAGTools.TextChunker"><code>RAGTools.TextChunker</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TextChunker &lt;: AbstractChunker</code></pre><p>Chunker when you provide text to <code>get_chunks</code> functions. Inputs are directly chunked</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.TrigramAnnotater" href="#RAGTools.TrigramAnnotater"><code>RAGTools.TrigramAnnotater</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TrigramAnnotater</code></pre><p>Annotation method where we score answer versus each context based on word-level trigrams that match.</p><p>It&#39;s very simple method (and it can loose some semantic meaning in longer sequences like negative), but it works reasonably well for both text and code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.last_message-Tuple{RAGResult}" href="#PromptingTools.last_message-Tuple{RAGResult}"><code>PromptingTools.last_message</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PT.last_message(result::RAGResult)</code></pre><p>Extract the last message from the RAGResult. It looks for <code>final_answer</code> first, then <code>answer</code> fields in the <code>conversations</code> dictionary. Returns <code>nothing</code> if not found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L1003-L1007">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.last_output-Tuple{RAGResult}" href="#PromptingTools.last_output-Tuple{RAGResult}"><code>PromptingTools.last_output</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extracts the last output (generated text answer) from the RAGResult.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L1020">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.pprint-Tuple{IO, RAGTools.AbstractAnnotatedNode}" href="#PromptingTools.pprint-Tuple{IO, RAGTools.AbstractAnnotatedNode}"><code>PromptingTools.pprint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PromptingTools.pprint(
    io::IO, node::AbstractAnnotatedNode;
    text_width::Int = displaysize(io)[2], add_newline::Bool = true)</code></pre><p>Pretty print the <code>node</code> to the <code>io</code> stream, including all its children</p><p>Supports only <code>node.style::Styler</code> for now.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L101-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PromptingTools.pprint-Tuple{IO, RAGTools.AbstractRAGResult}" href="#PromptingTools.pprint-Tuple{IO, RAGTools.AbstractRAGResult}"><code>PromptingTools.pprint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PT.pprint(
    io::IO, r::AbstractRAGResult; add_context::Bool = false,
    text_width::Int = displaysize(io)[2], annotater_kwargs...)</code></pre><p>Pretty print the RAG result <code>r</code> to the given <code>io</code> stream. </p><p>If <code>add_context</code> is <code>true</code>, the context will be printed as well. The <code>text_width</code> parameter can be used to control the width of the output.</p><p>You can provide additional keyword arguments to the annotater, eg, <code>add_sources</code>, <code>add_scores</code>, <code>min_score</code>, etc. See <code>annotate_support</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L1028-L1038">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.add_node_metadata!-Tuple{TrigramAnnotater, RAGTools.AnnotatedNode}" href="#RAGTools.add_node_metadata!-Tuple{TrigramAnnotater, RAGTools.AnnotatedNode}"><code>RAGTools.add_node_metadata!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_node_metadata!(annotater::TrigramAnnotater,
    root::AnnotatedNode; add_sources::Bool = true, add_scores::Bool = true,
    sources::Union{Nothing, AbstractVector{&lt;:AbstractString}} = nothing)</code></pre><p>Adds metadata to the children of <code>root</code>. Metadata includes sources and scores, if requested.</p><p>Optionally, it can add a list of <code>sources</code> at the end of the printed text.</p><p>The metadata is added by inserting new nodes in the <code>root</code> children list (with no children of its own to be printed out).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L318-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.airag-Tuple{RAGTools.AbstractRAGConfig, RAGTools.AbstractDocumentIndex}" href="#RAGTools.airag-Tuple{RAGTools.AbstractRAGConfig, RAGTools.AbstractDocumentIndex}"><code>RAGTools.airag</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">airag(cfg::AbstractRAGConfig, index::AbstractDocumentIndex;
    question::AbstractString,
    verbose::Integer = 1, return_all::Bool = false,
    api_kwargs::NamedTuple = NamedTuple(),
    retriever::AbstractRetriever = cfg.retriever,
    retriever_kwargs::NamedTuple = NamedTuple(),
    generator::AbstractGenerator = cfg.generator,
    generator_kwargs::NamedTuple = NamedTuple(),
    cost_tracker = Threads.Atomic{Float64}(0.0))</code></pre><p>High-level wrapper for Retrieval-Augmented Generation (RAG), it combines together the <code>retrieve</code> and <code>generate!</code> steps which you can customize if needed.</p><p>The simplest version first finds the relevant chunks in <code>index</code> for the <code>question</code> and then sends these chunks to the AI model to help with generating a response to the <code>question</code>.</p><p>To customize the components, replace the types (<code>retriever</code>, <code>generator</code>) of the corresponding step of the RAG pipeline - or go into sub-routines within the steps. Eg, use <code>subtypes(AbstractRetriever)</code> to find the available options.</p><p><strong>Arguments</strong></p><ul><li><code>cfg::AbstractRAGConfig</code>: The configuration for the RAG pipeline. Defaults to <code>RAGConfig()</code>, where you can swap sub-types to customize the pipeline.</li><li><code>index::AbstractDocumentIndex</code>: The chunk index to search for relevant text.</li><li><code>question::AbstractString</code>: The question to be answered.</li><li><code>return_all::Bool</code>: If <code>true</code>, returns the details used for RAG along with the response.</li><li><code>verbose::Integer</code>: If <code>&gt;0</code>, enables verbose logging. The higher the number, the more nested functions will log.</li><li><code>api_kwargs</code>: API parameters that will be forwarded to ALL of the API calls (<code>aiembed</code>, <code>aigenerate</code>, and <code>aiextract</code>).</li><li><code>retriever::AbstractRetriever</code>: The retriever to use for finding relevant chunks. Defaults to <code>cfg.retriever</code>, eg, <code>SimpleRetriever</code> (with no question rephrasing).</li><li><code>retriever_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>retriever</code> call. Examples of important ones:<ul><li><code>top_k::Int</code>: Number of top candidates to retrieve based on embedding similarity.</li><li><code>top_n::Int</code>: Number of candidates to return after reranking.</li><li><code>tagger::AbstractTagger</code>: Tagger to use for tagging the chunks. Defaults to <code>NoTagger()</code>.</li><li><code>tagger_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>tagger</code> call. You could provide the explicit tags directly with <code>PassthroughTagger</code> and <code>tagger_kwargs = (; tags = [&quot;tag1&quot;, &quot;tag2&quot;])</code>.</li></ul></li><li><code>generator::AbstractGenerator</code>: The generator to use for generating the answer. Defaults to <code>cfg.generator</code>, eg, <code>SimpleGenerator</code>.</li><li><code>generator_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>generator</code> call. Examples of important ones:<ul><li><code>answerer_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>answerer</code> call. Examples:<ul><li><code>model</code>: The model to use for generating the answer. Defaults to <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: The template to use for the <code>aigenerate</code> function. Defaults to <code>:RAGAnswerFromContext</code>.</li></ul></li><li><code>refiner::AbstractRefiner</code>: The method to use for refining the answer. Defaults to <code>generator.refiner</code>, eg, <code>NoRefiner</code>.</li><li><code>refiner_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>refiner</code> call.<ul><li><code>model</code>: The model to use for generating the answer. Defaults to <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: The template to use for the <code>aigenerate</code> function. Defaults to <code>:RAGAnswerRefiner</code>.</li></ul></li></ul></li><li><code>cost_tracker</code>: An atomic counter to track the total cost of the operations (if you want to track the cost of multiple pipeline runs - it passed around in the pipeline).</li></ul><p><strong>Returns</strong></p><ul><li>If <code>return_all</code> is <code>false</code>, returns the generated message (<code>msg</code>).</li><li>If <code>return_all</code> is <code>true</code>, returns the detail of the full pipeline in <code>RAGResult</code> (see the docs).</li></ul><p>See also <code>build_index</code>, <code>retrieve</code>, <code>generate!</code>, <code>RAGResult</code>, <code>getpropertynested</code>, <code>setpropertynested</code>, <code>merge_kwargs_nested</code>, <code>ChunkKeywordsIndex</code>.</p><p><strong>Examples</strong></p><p>Using <code>airag</code> to get a response for a question:</p><pre><code class="language-julia hljs">index = build_index(...)  # create an index
question = &quot;How to make a barplot in Makie.jl?&quot;
msg = airag(index; question)</code></pre><p>To understand the details of the RAG process, use <code>return_all=true</code></p><pre><code class="language-julia hljs">msg, details = airag(index; question, return_all = true)
# details is a RAGDetails object with all the internal steps of the `airag` function</code></pre><p>You can also pretty-print <code>details</code> to highlight generated text vs text that is supported by context. It also includes annotations of which context was used for each part of the response (where available).</p><pre><code class="language-julia hljs">PT.pprint(details)</code></pre><p>Example with advanced retrieval (with question rephrasing and reranking (requires <code>COHERE_API_KEY</code>). We will obtain top 100 chunks from embeddings (<code>top_k</code>) and top 5 chunks from reranking (<code>top_n</code>). In addition, it will be done with a &quot;custom&quot; locally-hosted model.</p><pre><code class="language-julia hljs">cfg = RAGConfig(; retriever = AdvancedRetriever())

# kwargs will be big and nested, let&#39;s prepare them upfront
# we specify &quot;custom&quot; model for each component that calls LLM
kwargs = (
    retriever_kwargs = (;
        top_k = 100,
        top_n = 5,
        rephraser_kwargs = (;
            model = &quot;custom&quot;),
        embedder_kwargs = (;
            model = &quot;custom&quot;),
        tagger_kwargs = (;
            model = &quot;custom&quot;)),
    generator_kwargs = (;
        answerer_kwargs = (;
            model = &quot;custom&quot;),
        refiner_kwargs = (;
            model = &quot;custom&quot;)),
    api_kwargs = (;
        url = &quot;http://localhost:8080&quot;))

result = airag(cfg, index, question; kwargs...)</code></pre><p>If you want to use hybrid retrieval (embeddings + BM25), you can easily create an additional index based on keywords  and pass them both into a <code>MultiIndex</code>. </p><p>You need to provide an explicit config, so the pipeline knows how to handle each index in the search similarity phase (<code>finder</code>).</p><pre><code class="language-julia hljs">index = # your existing index

# create the multi-index with the keywords index
index_keywords = ChunkKeywordsIndex(index)
multi_index = MultiIndex([index, index_keywords])

# define the similarity measures for the indices that you have (same order)
finder = RT.MultiFinder([RT.CosineSimilarity(), RT.BM25Similarity()])
cfg = RAGConfig(; retriever=AdvancedRetriever(; processor=RT.KeywordsProcessor(), finder))

# Run the pipeline with the new hybrid retrieval (return the `RAGResult` to see the details)
result = airag(cfg, multi_index; question, return_all=true)

# Pretty-print the result
PT.pprint(result)</code></pre><p>For easier manipulation of nested kwargs, see utilities <code>getpropertynested</code>, <code>setpropertynested</code>, <code>merge_kwargs_nested</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L527-L650">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.align_node_styles!-Tuple{TrigramAnnotater, AbstractVector{&lt;:RAGTools.AnnotatedNode}}" href="#RAGTools.align_node_styles!-Tuple{TrigramAnnotater, AbstractVector{&lt;:RAGTools.AnnotatedNode}}"><code>RAGTools.align_node_styles!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">align_node_styles!(annotater::TrigramAnnotater, nodes::AbstractVector{&lt;:AnnotatedNode}; kwargs...)</code></pre><p>Aligns the styles of the nodes based on the surrounding nodes (&quot;fill-in-the-middle&quot;). </p><p>If the node has no score, but the surrounding nodes have the same style, the node will inherit the style of the surrounding nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L191-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.annotate_support-Tuple{TrigramAnnotater, AbstractString, AbstractVector}" href="#RAGTools.annotate_support-Tuple{TrigramAnnotater, AbstractString, AbstractVector}"><code>RAGTools.annotate_support</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">annotate_support(annotater::TrigramAnnotater, answer::AbstractString,
    context::AbstractVector; min_score::Float64 = 0.5,
    skip_trigrams::Bool = true, hashed::Bool = true,
    sources::Union{Nothing, AbstractVector{&lt;:AbstractString}} = nothing,
    min_source_score::Float64 = 0.25,
    add_sources::Bool = true,
    add_scores::Bool = true, kwargs...)</code></pre><p>Annotates the <code>answer</code> with the overlap/what&#39;s supported in <code>context</code> and returns the annotated tree of nodes representing the <code>answer</code></p><p>Returns a &quot;root&quot; node with children nodes representing the sentences/code blocks in the <code>answer</code>. Only the &quot;leaf&quot; nodes are to be printed (to avoid duplication), &quot;leaf&quot; nodes are those with NO children.</p><p>Default logic: </p><ul><li>Split into sentences/code blocks, then into tokens (~words).</li><li>Then match each token (~word) exactly.</li><li>If no exact match found, count trigram-based match (include the surrounding tokens for better contextual awareness).</li><li>If the match is higher than <code>min_score</code>, it&#39;s recorded in the <code>score</code> of the node.</li></ul><p><strong>Arguments</strong></p><ul><li><code>annotater::TrigramAnnotater</code>: Annotater to use</li><li><code>answer::AbstractString</code>: Text to annotate</li><li><code>context::AbstractVector</code>: Context to annotate against, ie, look for &quot;support&quot; in the texts in <code>context</code></li><li><code>min_score::Float64</code>: Minimum score to consider a match. Default: 0.5, which means that half of the trigrams of each word should match</li><li><code>skip_trigrams::Bool</code>: Whether to potentially skip trigram matching if exact full match is found. Default: true</li><li><code>hashed::Bool</code>: Whether to use hashed trigrams. It&#39;s harder to debug, but it&#39;s much faster for larger texts (hashed text are held in a Set to deduplicate). Default: true</li><li><code>sources::Union{Nothing, AbstractVector{&lt;:AbstractString}}</code>: Sources to add at the end of the context. Default: nothing</li><li><code>min_source_score::Float64</code>: Minimum score to consider/to display a source. Default: 0.25, which means that at least a quarter of the trigrams of each word should match to some context. The threshold is lower than <code>min_score</code>, because it&#39;s average across ALL words in a block, so it&#39;s much harder to match fully with generated text.</li><li><code>add_sources::Bool</code>: Whether to add sources at the end of each code block/sentence. Sources are addded in the square brackets like &quot;[1]&quot;. Default: true</li><li><code>add_scores::Bool</code>: Whether to add source-matching scores at the end of each code block/sentence. Scores are added in the square brackets like &quot;[0.75]&quot;. Default: true</li><li>kwargs: Additional keyword arguments to pass to <code>trigram_support!</code> and <code>set_node_style!</code>. See their documentation for more details (eg, customize the colors of the nodes based on the score)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">annotater = TrigramAnnotater()
context = [
    &quot;This is a test context.&quot;, &quot;Another context sentence.&quot;, &quot;Final piece of context.&quot;]
answer = &quot;This is a test context. Another context sentence.&quot;

annotated_root = annotate_support(annotater, answer, context)
pprint(annotated_root) # pretty print the annotated tree</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L416-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.annotate_support-Tuple{TrigramAnnotater, RAGTools.AbstractRAGResult}" href="#RAGTools.annotate_support-Tuple{TrigramAnnotater, RAGTools.AbstractRAGResult}"><code>RAGTools.annotate_support</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">annotate_support(
    annotater::TrigramAnnotater, result::AbstractRAGResult; min_score::Float64 = 0.5,
    skip_trigrams::Bool = true, hashed::Bool = true,
    min_source_score::Float64 = 0.25,
    add_sources::Bool = true,
    add_scores::Bool = true, kwargs...)</code></pre><p>Dispatch for <code>annotate_support</code> for <code>AbstractRAGResult</code> type. It extracts the <code>final_answer</code> and <code>context</code> from the <code>result</code> and calls <code>annotate_support</code> with them.</p><p>See <code>annotate_support</code> for more details.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">res = RAGResult(; question = &quot;&quot;, final_answer = &quot;This is a test.&quot;,
    context = [&quot;Test context.&quot;, &quot;Completely different&quot;])
annotated_root = annotate_support(annotater, res)
PT.pprint(annotated_root)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L509-L528">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.answer!-Tuple{RAGTools.SimpleAnswerer, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}" href="#RAGTools.answer!-Tuple{RAGTools.SimpleAnswerer, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.answer!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">answer!(
    answerer::SimpleAnswerer, index::AbstractDocumentIndex, result::AbstractRAGResult;
    model::AbstractString = PT.MODEL_CHAT, verbose::Bool = true,
    template::Symbol = :RAGAnswerFromContext,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Generates an answer using the <code>aigenerate</code> function with the provided <code>result.context</code> and <code>result.question</code>.</p><p><strong>Returns</strong></p><ul><li>Mutated <code>result</code> with <code>result.answer</code> and the full conversation saved in <code>result.conversations[:answer]</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>answerer::SimpleAnswerer</code>: The method to use for generating the answer. Uses <code>aigenerate</code>.</li><li><code>index::AbstractDocumentIndex</code>: The index containing chunks and sources.</li><li><code>result::AbstractRAGResult</code>: The result containing the context and question to generate the answer for.</li><li><code>model::AbstractString</code>: The model to use for generating the answer. Defaults to <code>PT.MODEL_CHAT</code>.</li><li><code>verbose::Bool</code>: If <code>true</code>, enables verbose logging.</li><li><code>template::Symbol</code>: The template to use for the <code>aigenerate</code> function. Defaults to <code>:RAGAnswerFromContext</code>.</li><li><code>cost_tracker</code>: An atomic counter to track the cost of the operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L93-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.bm25-Tuple{RAGTools.AbstractDocumentTermMatrix, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.bm25-Tuple{RAGTools.AbstractDocumentTermMatrix, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.bm25</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>bm25(     dtm::AbstractDocumentTermMatrix, query::AbstractVector{&lt;:AbstractString};     k1::Float32 = 1.2f0, b::Float32 = 0.75f0, normalize::Bool = false, normalize<em>max</em>tf::Real = 3,     normalize<em>min</em>doc<em>rel</em>length::Float32 = 1.0f0)</p><p>Scores all documents in <code>dtm</code> based on the <code>query</code>.</p><p>References: https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/</p><p><strong>Arguments</strong></p><ul><li><code>dtm</code>: A <code>DocumentTermMatrix</code> object.</li><li><code>query</code>: A vector of query tokens.</li><li><code>k1</code>: The k1 parameter for BM25.</li><li><code>b</code>: The b parameter for BM25.</li><li><code>normalize</code>: Whether to normalize the scores (returns scores between 0 and 1). </li></ul><p>Theoretically, if you choose <code>normalize_max_tf</code> and <code>normalize_min_doc_rel_length</code> to be too low, you could get scores greater than 1.</p><ul><li><code>normalize_max_tf</code>: The maximum term frequency to normalize to. 3 is a good default (assumes max 3 hits per document).</li><li><code>normalize_min_doc_rel_length</code>: The minimum document relative length to normalize to. 0.5 is a good default.</li></ul><p>Ideally, pick the minimum document relative length of the corpus that is non-zero <code>min_doc_rel_length = minimum(x for x in doc_rel_length(chunkdata(key_index)) if x &gt; 0) |&gt; Float32</code></p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">documents = [[&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;], [&quot;this&quot;, &quot;is&quot;, &quot;another&quot;, &quot;test&quot;], [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]]
dtm = document_term_matrix(documents)
query = [&quot;this&quot;]
scores = bm25(dtm, query)
# Returns array with 3 scores (one for each document)</code></pre><p>Normalization is done by dividing the score by the maximum possible score (given some assumptions). It&#39;s useful to be get results in the same range as cosine similarity scores and when comparing different queries or documents.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">documents = [[&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;], [&quot;this&quot;, &quot;is&quot;, &quot;another&quot;, &quot;test&quot;], [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]]
dtm = document_term_matrix(documents)
query = [&quot;this&quot;]
scores = bm25(dtm, query)
scores_norm = bm25(dtm, query; normalize = true)

## Make it more accurate for your dataset/index
normalize_max_tf = 3 # assume max term frequency is 3 (what is likely for your dataset? depends on chunk size, preprocessing, etc.)
normalize_min_doc_rel_length = minimum([x for x in doc_rel_length(dtm) if x &gt; 0]) |&gt; Float32
scores_norm = bm25(dtm, query; normalize = true, normalize_max_tf, normalize_min_doc_rel_length)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/bm25.jl#L102-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.build_context-Tuple{RAGTools.ContextEnumerator, RAGTools.AbstractDocumentIndex, RAGTools.AbstractCandidateChunks}" href="#RAGTools.build_context-Tuple{RAGTools.ContextEnumerator, RAGTools.AbstractDocumentIndex, RAGTools.AbstractCandidateChunks}"><code>RAGTools.build_context</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_context(contexter::ContextEnumerator,
    index::AbstractDocumentIndex, candidates::AbstractCandidateChunks;
    verbose::Bool = true,
    chunks_window_margin::Tuple{Int, Int} = (1, 1), kwargs...)

    build_context!(contexter::ContextEnumerator,
    index::AbstractDocumentIndex, result::AbstractRAGResult; kwargs...)</code></pre><p>Build context strings for each position in <code>candidates</code> considering a window margin around each position. If mutating version is used (<code>build_context!</code>), it will use <code>result.reranked_candidates</code> to update the <code>result.context</code> field.</p><p><strong>Arguments</strong></p><ul><li><code>contexter::ContextEnumerator</code>: The method to use for building the context. Enumerates the snippets.</li><li><code>index::AbstractDocumentIndex</code>: The index containing chunks and sources.</li><li><code>candidates::AbstractCandidateChunks</code>: Candidate chunks which contain positions to extract context from.</li><li><code>verbose::Bool</code>: If <code>true</code>, enables verbose logging.</li><li><code>chunks_window_margin::Tuple{Int, Int}</code>: A tuple indicating the margin (before, after) around each position to include in the context.  Defaults to <code>(1,1)</code>, which means 1 preceding and 1 suceeding chunk will be included. With <code>(0,0)</code>, only the matching chunks will be included.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{String}</code>: A vector of context strings, each corresponding to a position in <code>reranked_candidates</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">index = ChunkIndex(...)  # Assuming a proper index is defined
candidates = CandidateChunks(index.id, [2, 4], [0.1, 0.2])
context = build_context(ContextEnumerator(), index, candidates; chunks_window_margin=(0, 1)) # include only one following chunk for each matching chunk</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L9-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.build_index-Tuple{KeywordsIndexer, Vector{&lt;:AbstractString}}" href="#RAGTools.build_index-Tuple{KeywordsIndexer, Vector{&lt;:AbstractString}}"><code>RAGTools.build_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_index(
    indexer::KeywordsIndexer, files_or_docs::Vector{&lt;:AbstractString};
    verbose::Integer = 1,
    extras::Union{Nothing, AbstractVector} = nothing,
    index_id = gensym(&quot;ChunkKeywordsIndex&quot;),
    chunker::AbstractChunker = indexer.chunker,
    chunker_kwargs::NamedTuple = NamedTuple(),
    processor::AbstractProcessor = indexer.processor,
    processor_kwargs::NamedTuple = NamedTuple(),
    tagger::AbstractTagger = indexer.tagger,
    tagger_kwargs::NamedTuple = NamedTuple(),
    api_kwargs::NamedTuple = NamedTuple(),
    cost_tracker = Threads.Atomic{Float64}(0.0))</code></pre><p>Builds a <code>ChunkKeywordsIndex</code> from the provided files or documents to support keyword-based search (BM25).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L708-L724">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.build_index-Tuple{RAGTools.AbstractIndexBuilder, Vector{&lt;:AbstractString}}" href="#RAGTools.build_index-Tuple{RAGTools.AbstractIndexBuilder, Vector{&lt;:AbstractString}}"><code>RAGTools.build_index</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_index(
    indexer::AbstractIndexBuilder, files_or_docs::Vector{&lt;:AbstractString};
    verbose::Integer = 1,
    extras::Union{Nothing, AbstractVector} = nothing,
    index_id = gensym(&quot;ChunkEmbeddingsIndex&quot;),
    chunker::AbstractChunker = indexer.chunker,
    chunker_kwargs::NamedTuple = NamedTuple(),
    embedder::AbstractEmbedder = indexer.embedder,
    embedder_kwargs::NamedTuple = NamedTuple(),
    tagger::AbstractTagger = indexer.tagger,
    tagger_kwargs::NamedTuple = NamedTuple(),
    api_kwargs::NamedTuple = NamedTuple(),
    cost_tracker = Threads.Atomic{Float64}(0.0))</code></pre><p>Build an INDEX for RAG (Retriever-Augmented Generation) applications from the provided file paths.  INDEX is a object storing the document chunks and their embeddings (and potentially other information).</p><p>The function processes each file or document (depending on <code>chunker</code>), splits its content into chunks, embeds these chunks,  optionally extracts metadata, and then combines this information into a retrievable index.</p><p>Define your own methods via <code>indexer</code> and its subcomponents (<code>chunker</code>, <code>embedder</code>, <code>tagger</code>).</p><p><strong>Arguments</strong></p><ul><li><code>indexer::AbstractIndexBuilder</code>: The indexing logic to use. Default is <code>SimpleIndexer()</code>.</li><li><code>files_or_docs</code>: A vector of valid file paths OR string documents to be indexed (chunked and embedded). Specify which mode to use via <code>chunker</code>.</li><li><code>verbose</code>: An Integer specifying the verbosity of the logs. Default is <code>1</code> (high-level logging). <code>0</code> is disabled.</li><li><code>extras</code>: An optional vector of extra information to be stored with each chunk. Default is <code>nothing</code>.</li><li><code>index_id</code>: A unique identifier for the index. Default is a generated symbol.</li><li><code>chunker</code>: The chunker logic to use for splitting the documents. Default is <code>TextChunker()</code>.</li><li><code>chunker_kwargs</code>: Parameters to be provided to the <code>get_chunks</code> function. Useful to change the <code>separators</code> or <code>max_length</code>.<ul><li><code>sources</code>: A vector of strings indicating the source of each chunk. Default is equal to <code>files_or_docs</code>.</li></ul></li><li><code>embedder</code>: The embedder logic to use for embedding the chunks. Default is <code>BatchEmbedder()</code>.</li><li><code>embedder_kwargs</code>: Parameters to be provided to the <code>get_embeddings</code> function. Useful to change the <code>target_batch_size_length</code> or reduce asyncmap tasks <code>ntasks</code>.<ul><li><code>model</code>: The model to use for embedding. Default is <code>PT.MODEL_EMBEDDING</code>.</li></ul></li><li><code>tagger</code>: The tagger logic to use for extracting tags from the chunks. Default is <code>NoTagger()</code>, ie, skip tag extraction. There are also <code>PassthroughTagger</code> and <code>OpenTagger</code>.</li><li><code>tagger_kwargs</code>: Parameters to be provided to the <code>get_tags</code> function.<ul><li><code>model</code>: The model to use for tags extraction. Default is <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: A template to be used for tags extraction. Default is <code>:RAGExtractMetadataShort</code>.</li><li><code>tags</code>: A vector of vectors of strings directly providing the tags for each chunk. Applicable for <code>tagger::PasstroughTagger</code>.</li></ul></li><li><code>api_kwargs</code>: Parameters to be provided to the API endpoint. Shared across all API calls if provided.</li><li><code>cost_tracker</code>: A <code>Threads.Atomic{Float64}</code> object to track the total cost of the API calls. Useful to pass the total cost to the parent call.</li></ul><p><strong>Returns</strong></p><ul><li><code>ChunkEmbeddingsIndex</code>: An object containing the compiled index of chunks, embeddings, tags, vocabulary, and sources.</li></ul><p>See also: <code>ChunkEmbeddingsIndex</code>, <code>get_chunks</code>, <code>get_embeddings</code>, <code>get_tags</code>, <code>CandidateChunks</code>, <code>find_closest</code>, <code>find_tags</code>, <code>rerank</code>, <code>retrieve</code>, <code>generate!</code>, <code>airag</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Default is loading a vector of strings and chunking them (`TextChunker()`)
index = build_index(SimpleIndexer(), texts; chunker_kwargs = (; max_length=10))

# Another example with tags extraction, splitting only sentences and verbose output
# Assuming `test_files` is a vector of file paths
indexer = SimpleIndexer(chunker=FileChunker(), tagger=OpenTagger())
index = build_index(indexer, test_files; 
        chunker_kwargs(; separators=[&quot;. &quot;]), verbose=true)</code></pre><p><strong>Notes</strong></p><ul><li>If you get errors about exceeding embedding input sizes, first check the <code>max_length</code> in your chunks.  If that does NOT resolve the issue, try changing the <code>embedding_kwargs</code>.  In particular, reducing the <code>target_batch_size_length</code> parameter (eg, 10_000) and number of tasks <code>ntasks=1</code>.  Some providers cannot handle large batch sizes (eg, Databricks).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L602-L668">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.build_qa_evals-Tuple{Vector{&lt;:AbstractString}, Vector{&lt;:AbstractString}}" href="#RAGTools.build_qa_evals-Tuple{Vector{&lt;:AbstractString}, Vector{&lt;:AbstractString}}"><code>RAGTools.build_qa_evals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_qa_evals(doc_chunks::Vector{&lt;:AbstractString}, sources::Vector{&lt;:AbstractString};
               model=PT.MODEL_CHAT, instructions=&quot;None.&quot;, qa_template::Symbol=:RAGCreateQAFromContext, 
               verbose::Bool=true, api_kwargs::NamedTuple = NamedTuple(), kwargs...) -&gt; Vector{QAEvalItem}</code></pre><p>Create a collection of question and answer evaluations (<code>QAEvalItem</code>) from document chunks and sources.  This function generates Q&amp;A pairs based on the provided document chunks, using a specified AI model and template.</p><p><strong>Arguments</strong></p><ul><li><code>doc_chunks::Vector{&lt;:AbstractString}</code>: A vector of document chunks, each representing a segment of text.</li><li><code>sources::Vector{&lt;:AbstractString}</code>: A vector of source identifiers corresponding to each chunk in <code>doc_chunks</code> (eg, filenames or paths).</li><li><code>model</code>: The AI model used for generating Q&amp;A pairs. Default is <code>PT.MODEL_CHAT</code>.</li><li><code>instructions::String</code>: Additional instructions or context to provide to the model generating QA sets. Defaults to &quot;None.&quot;.</li><li><code>qa_template::Symbol</code>: A template symbol that dictates the AITemplate that will be used. It must have placeholder <code>context</code>. Default is <code>:CreateQAFromContext</code>.</li><li><code>api_kwargs::NamedTuple</code>: Parameters that will be forwarded to the API endpoint.</li><li><code>verbose::Bool</code>: If <code>true</code>, additional information like costs will be logged. Defaults to <code>true</code>.</li></ul><p><strong>Returns</strong></p><p><code>Vector{QAEvalItem}</code>: A vector of <code>QAEvalItem</code> structs, each containing a source, context, question, and answer. Invalid or empty items are filtered out.</p><p><strong>Notes</strong></p><ul><li>The function internally uses <code>aiextract</code> to generate Q&amp;A pairs based on the provided <code>qa_template</code>. So you can use any kwargs that you want.</li><li>Each <code>QAEvalItem</code> includes the context (document chunk), the generated question and answer, and the source.</li><li>The function tracks and reports the cost of AI calls if <code>verbose</code> is enabled.</li><li>Items where the question, answer, or context is empty are considered invalid and are filtered out.</li></ul><p><strong>Examples</strong></p><p>Creating Q&amp;A evaluations from a set of document chunks:</p><pre><code class="language-julia hljs">doc_chunks = [&quot;Text from document 1&quot;, &quot;Text from document 2&quot;]
sources = [&quot;source1&quot;, &quot;source2&quot;]
qa_evals = build_qa_evals(doc_chunks, sources)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/evaluation.jl#L65-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.build_tags" href="#RAGTools.build_tags"><code>RAGTools.build_tags</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Builds a matrix of tags and a vocabulary list. REQUIRES SparseArrays, LinearAlgebra, Unicode packages to be loaded!!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rag_interface.jl#L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.build_tags-Tuple{RAGTools.AbstractTagger, AbstractVector{&lt;:AbstractVector{&lt;:AbstractString}}}" href="#RAGTools.build_tags-Tuple{RAGTools.AbstractTagger, AbstractVector{&lt;:AbstractVector{&lt;:AbstractString}}}"><code>RAGTools.build_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_tags(
    tagger::AbstractTagger, chunk_metadata::AbstractVector{
        &lt;:AbstractVector{&lt;:AbstractString},
    })</code></pre><p>Builds a sparse matrix of tags and a vocabulary from the given vector of chunk metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L572-L579">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.build_tags-Tuple{RAGTools.AbstractTagger, Nothing}" href="#RAGTools.build_tags-Tuple{RAGTools.AbstractTagger, Nothing}"><code>RAGTools.build_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_tags(tagger::AbstractTagger, chunk_tags::Nothing; kwargs...)</code></pre><p>No-op that skips any tag building, returning <code>nothing, nothing</code></p><p>Otherwise, it would build the sparse matrix and the vocabulary (requires <code>SparseArrays</code> and <code>LinearAlgebra</code> packages to be loaded).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L561-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.chunkdata-Tuple{ChunkKeywordsIndex, AbstractVector{&lt;:Integer}}" href="#RAGTools.chunkdata-Tuple{ChunkKeywordsIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.chunkdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Access chunkdata for a subset of chunks, <code>chunk_idx</code> is a vector of chunk indices in the index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.chunkdata-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:Integer}}" href="#RAGTools.chunkdata-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.chunkdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Access chunkdata for a subset of chunks, <code>chunk_idx</code> is a vector of chunk indices in the index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.chunkdata-Tuple{SubChunkIndex, AbstractVector{&lt;:Integer}}" href="#RAGTools.chunkdata-Tuple{SubChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.chunkdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Access chunkdata for a subset of chunks, <code>chunk_idx</code> is a vector of chunk indices in the index</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.cohere_api-Tuple{}" href="#RAGTools.cohere_api-Tuple{}"><code>RAGTools.cohere_api</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cohere_api(;
api_key::AbstractString,
endpoint::String,
url::AbstractString=&quot;https://api.cohere.ai/v1&quot;,
http_kwargs::NamedTuple=NamedTuple(),
kwargs...)</code></pre><p>Lightweight wrapper around the Cohere API. See https://cohere.com/docs for more details.</p><p><strong>Arguments</strong></p><ul><li><code>api_key</code>: Your Cohere API key. You can get one from https://dashboard.cohere.com/welcome/register (trial access is for free).</li><li><code>endpoint</code>: The Cohere endpoint to call. </li><li><code>url</code>: The base URL for the Cohere API. Default is <code>https://api.cohere.ai/v1</code>.</li><li><code>http_kwargs</code>: Any additional keyword arguments to pass to <code>HTTP.post</code>.</li><li><code>kwargs</code>: Any additional keyword arguments to pass to the Cohere API.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/api_services.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.create_permutation_instruction-Tuple{AbstractVector{&lt;:AbstractString}}" href="#RAGTools.create_permutation_instruction-Tuple{AbstractVector{&lt;:AbstractString}}"><code>RAGTools.create_permutation_instruction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_permutation_instruction(
    context::AbstractVector{&lt;:AbstractString}; rank_start::Integer = 1,
    rank_end::Integer = 100, max_length::Integer = 512, template::Symbol = :RAGRankGPT)</code></pre><p>Creates rendered template with injected <code>context</code> passages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rank_gpt.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.create_websearch-Tuple{AbstractString}" href="#RAGTools.create_websearch-Tuple{AbstractString}"><code>RAGTools.create_websearch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_websearch(query::AbstractString;
    api_key::AbstractString,
    search_depth::AbstractString = &quot;basic&quot;)</code></pre><p><strong>Arguments</strong></p><ul><li><code>query::AbstractString</code>: The query to search for.</li><li><code>api_key::AbstractString</code>: The API key to use for the search. Get an API key from <a href="https://tavily.com">Tavily</a>.</li><li><code>search_depth::AbstractString</code>: The depth of the search. Can be either &quot;basic&quot; or &quot;advanced&quot;. Default is &quot;basic&quot;. Advanced search calls equal to 2 requests.</li><li><code>include_answer::Bool</code>: Whether to include the answer in the search results. Default is <code>false</code>.</li><li><code>include_raw_content::Bool</code>: Whether to include the raw content in the search results. Default is <code>false</code>.</li><li><code>max_results::Integer</code>: The maximum number of results to return. Default is 5.</li><li><code>include_images::Bool</code>: Whether to include images in the search results. Default is <code>false</code>.</li><li><code>include_domains::AbstractVector{&lt;:AbstractString}</code>: A list of domains to include in the search results. Default is an empty list.</li><li><code>exclude_domains::AbstractVector{&lt;:AbstractString}</code>: A list of domains to exclude from the search results. Default is an empty list.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">r = create_websearch(&quot;Who is King Charles?&quot;)</code></pre><p>Even better, you can get not just the results but also the answer:</p><pre><code class="language-julia hljs">r = create_websearch(&quot;Who is King Charles?&quot;; include_answer = true)</code></pre><p>See <a href="https://docs.tavily.com/docs/tavily-api/rest_api">Rest API documentation</a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/api_services.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.document_term_matrix-Union{Tuple{AbstractVector{&lt;:AbstractVector{T}}}, Tuple{T}} where T&lt;:AbstractString" href="#RAGTools.document_term_matrix-Union{Tuple{AbstractVector{&lt;:AbstractVector{T}}}, Tuple{T}} where T&lt;:AbstractString"><code>RAGTools.document_term_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>document<em>term</em>matrix(     documents::AbstractVector{&lt;:AbstractVector{T}};     min<em>term</em>freq::Int = 1, max_terms::Int = typemax(Int)) where {T &lt;: AbstractString}</p><p>Builds a sparse matrix of term frequencies and document lengths from the given vector of documents wrapped in type <code>DocumentTermMatrix</code>.</p><p>Expects a vector of preprocessed (tokenized) documents, where each document is a vector of strings (clean tokens).</p><p>Returns: <code>DocumentTermMatrix</code></p><p><strong>Arguments</strong></p><ul><li><code>documents</code>: A vector of documents, where each document is a vector of terms (clean tokens).</li><li><code>min_term_freq</code>: The minimum frequency a term must have to be included in the vocabulary, eg, <code>min_term_freq = 2</code> means only terms that appear at least twice will be included.</li><li><code>max_terms</code>: The maximum number of terms to include in the vocabulary, eg, <code>max_terms = 100</code> means only the 100 most frequent terms will be included.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">documents = [[&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;], [&quot;this&quot;, &quot;is&quot;, &quot;another&quot;, &quot;test&quot;], [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]]
dtm = document_term_matrix(documents)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/bm25.jl#L28-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.extract_ranking-Tuple{AbstractString}" href="#RAGTools.extract_ranking-Tuple{AbstractString}"><code>RAGTools.extract_ranking</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_ranking(str::AbstractString)</code></pre><p>Extracts the ranking from the response into a sorted array of integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rank_gpt.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_closest" href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_closest(
    finder::BM25Similarity, dtm::AbstractDocumentTermMatrix,
    query_emb::AbstractVector{&lt;:Real}, query_tokens::AbstractVector{&lt;:AbstractString} = String[];
    top_k::Int = 100, minimum_similarity::AbstractFloat = -1.0, kwargs...)</code></pre><p>Finds the indices of chunks (represented by DocumentTermMatrix in <code>dtm</code>) that are closest to query tokens (<code>query_tokens</code>) using BM25.</p><p>Reference: <a href="https://en.wikipedia.org/wiki/Okapi_BM25">Wikipedia: BM25</a>. Implementation follows: <a href="https://opensourceconnections.com/blog/2015/10/16/bm25-the-next-generation-of-lucene-relevation/">The Next Generation of Lucene Relevance</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L456-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_closest" href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_closest(
    finder::BitPackedCosineSimilarity, emb::AbstractMatrix{&lt;:Bool},
    query_emb::AbstractVector{&lt;:Real}, query_tokens::AbstractVector{&lt;:AbstractString} = String[];
    top_k::Int = 100, rescore_multiplier::Int = 4, minimum_similarity::AbstractFloat = -1.0, kwargs...)</code></pre><p>Finds the indices of chunks (represented by embeddings in <code>emb</code>) that are closest to query embedding (<code>query_emb</code>) using bit-packed binary embeddings (in the index).</p><p>This is a two-pass approach:</p><ul><li>First pass: Hamming distance in bit-packed binary form to get the <code>top_k * rescore_multiplier</code> (i.e., more than top_k) candidates.</li><li>Second pass: Rescore the candidates with float embeddings and return the top_k.</li></ul><p>Returns only <code>top_k</code> closest indices.</p><p>Reference: <a href="https://huggingface.co/blog/embedding-quantization#binary-quantization-in-vector-databases">HuggingFace: Embedding Quantization</a>.</p><p><strong>Examples</strong></p><p>Convert any Float embeddings to bit-packed binary like this:</p><pre><code class="language-julia hljs">bitpacked_emb = pack_bits(emb.&gt;0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L411-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_closest" href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_closest(
    finder::CosineSimilarity, emb::AbstractMatrix{&lt;:Real},
    query_emb::AbstractVector{&lt;:Real}, query_tokens::AbstractVector{&lt;:AbstractString} = String[];
    top_k::Int = 100, minimum_similarity::AbstractFloat = -1.0, kwargs...)</code></pre><p>Finds the indices of chunks (represented by embeddings in <code>emb</code>) that are closest (in cosine similarity for <code>CosineSimilarity()</code>) to query embedding (<code>query_emb</code>). </p><p><code>finder</code> is the logic used for the similarity search. Default is <code>CosineSimilarity</code>.</p><p>If <code>minimum_similarity</code> is provided, only indices with similarity greater than or equal to it are returned.  Similarity can be between -1 and 1 (-1 = completely opposite, 1 = exactly the same).</p><p>Returns only <code>top_k</code> closest indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L185-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_closest" href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_closest(
    finder::BinaryCosineSimilarity, emb::AbstractMatrix{&lt;:Bool},
    query_emb::AbstractVector{&lt;:Real}, query_tokens::AbstractVector{&lt;:AbstractString} = String[];
    top_k::Int = 100, rescore_multiplier::Int = 4, minimum_similarity::AbstractFloat = -1.0, kwargs...)</code></pre><p>Finds the indices of chunks (represented by embeddings in <code>emb</code>) that are closest to query embedding (<code>query_emb</code>) using binary embeddings (in the index).</p><p>This is a two-pass approach:</p><ul><li>First pass: Hamming distance in binary form to get the <code>top_k * rescore_multiplier</code> (ie, more than top_k) candidates.</li><li>Second pass: Rescore the candidates with float embeddings and return the top_k.</li></ul><p>Returns only <code>top_k</code> closest indices.</p><p>Reference: <a href="https://huggingface.co/blog/embedding-quantization#binary-quantization-in-vector-databases">HuggingFace: Embedding Quantization</a>.</p><p><strong>Examples</strong></p><p>Convert any Float embeddings to binary like this:</p><pre><code class="language-julia hljs">binary_emb = map(&gt;(0), emb)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L367-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_closest" href="#RAGTools.find_closest"><code>RAGTools.find_closest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_closest(
    finder::AbstractSimilarityFinder, index::AbstractChunkIndex,
    query_emb::AbstractVector{&lt;:Real}, query_tokens::AbstractVector{&lt;:AbstractString} = String[];
    top_k::Int = 100, kwargs...)</code></pre><p>Finds the indices of chunks (represented by embeddings in <code>index</code>) that are closest to query embedding (<code>query_emb</code>).</p><p>Returns only <code>top_k</code> closest indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L219-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_tags-Tuple{RAGTools.AnyTagFilter, RAGTools.AbstractChunkIndex, Union{Regex, AbstractString}}" href="#RAGTools.find_tags-Tuple{RAGTools.AnyTagFilter, RAGTools.AbstractChunkIndex, Union{Regex, AbstractString}}"><code>RAGTools.find_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_tags(method::AnyTagFilter, index::AbstractChunkIndex,
    tag::Union{AbstractString, Regex}; kwargs...)

find_tags(method::AnyTagFilter, index::AbstractChunkIndex,
    tags::Vector{T}; kwargs...) where {T &lt;: Union{AbstractString, Regex}}</code></pre><p>Finds the indices of chunks (represented by tags in <code>index</code>) that have ANY OF the specified <code>tag</code> or <code>tags</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L496-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_tags-Union{Tuple{T}, Tuple{RAGTools.AllTagFilter, RAGTools.AbstractChunkIndex, Vector{T}}} where T&lt;:Union{Regex, AbstractString}" href="#RAGTools.find_tags-Union{Tuple{T}, Tuple{RAGTools.AllTagFilter, RAGTools.AbstractChunkIndex, Vector{T}}} where T&lt;:Union{Regex, AbstractString}"><code>RAGTools.find_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_tags(method::AllTagFilter, index::AbstractChunkIndex,
    tag::Union{AbstractString, Regex}; kwargs...)

find_tags(method::AllTagFilter, index::AbstractChunkIndex,
    tags::Vector{T}; kwargs...) where {T &lt;: Union{AbstractString, Regex}}</code></pre><p>Finds the indices of chunks (represented by tags in <code>index</code>) that have ALL OF the specified <code>tag</code> or <code>tags</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L530-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.find_tags-Union{Tuple{T}, Tuple{RAGTools.NoTagFilter, RAGTools.AbstractChunkIndex, Union{AbstractVector{&lt;:T}, T}}} where T&lt;:Union{Nothing, Regex, AbstractString}" href="#RAGTools.find_tags-Union{Tuple{T}, Tuple{RAGTools.NoTagFilter, RAGTools.AbstractChunkIndex, Union{AbstractVector{&lt;:T}, T}}} where T&lt;:Union{Nothing, Regex, AbstractString}"><code>RAGTools.find_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_tags(method::NoTagFilter, index::AbstractChunkIndex,
    tags::Union{T, AbstractVector{&lt;:T}}; kwargs...) where {T &lt;:
                                                           Union{
    AbstractString, Regex, Nothing}}
    tags; kwargs...)</code></pre><p>Returns all chunks in the index, ie, no filtering, so we simply return <code>nothing</code> (easier for dispatch).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L566-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.generate!-Tuple{RAGTools.AbstractGenerator, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}" href="#RAGTools.generate!-Tuple{RAGTools.AbstractGenerator, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.generate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate!(
    generator::AbstractGenerator, index::AbstractDocumentIndex, result::AbstractRAGResult;
    verbose::Integer = 1,
    api_kwargs::NamedTuple = NamedTuple(),
    contexter::AbstractContextBuilder = generator.contexter,
    contexter_kwargs::NamedTuple = NamedTuple(),
    answerer::AbstractAnswerer = generator.answerer,
    answerer_kwargs::NamedTuple = NamedTuple(),
    refiner::AbstractRefiner = generator.refiner,
    refiner_kwargs::NamedTuple = NamedTuple(),
    postprocessor::AbstractPostprocessor = generator.postprocessor,
    postprocessor_kwargs::NamedTuple = NamedTuple(),
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Generate the response using the provided <code>generator</code> and the <code>index</code> and <code>result</code>. It is the second step in the RAG pipeline (after <code>retrieve</code>)</p><p>Returns the mutated <code>result</code> with the <code>result.final_answer</code> and the full conversation saved in <code>result.conversations[:final_answer]</code>.</p><p><strong>Notes</strong></p><ul><li>The default flow is <code>build_context!</code> -&gt; <code>answer!</code> -&gt; <code>refine!</code> -&gt; <code>postprocess!</code>.</li><li><code>contexter</code> is the method to use for building the context, eg, simply enumerate the context chunks with <code>ContextEnumerator</code>.</li><li><code>answerer</code> is the standard answer generation step with LLMs.</li><li><code>refiner</code> step allows the LLM to critique itself and refine its own answer.</li><li><code>postprocessor</code> step allows for additional processing of the answer, eg, logging, saving conversations, etc.</li><li>All of its sub-routines operate by mutating the <code>result</code> object (and adding their part).</li><li>Discover available sub-types for each step with <code>subtypes(AbstractRefiner)</code> and similar for other abstract types.</li></ul><p><strong>Arguments</strong></p><ul><li><code>generator::AbstractGenerator</code>: The <code>generator</code> to use for generating the answer. Can be <code>SimpleGenerator</code> or <code>AdvancedGenerator</code>.</li><li><code>index::AbstractDocumentIndex</code>: The index containing chunks and sources.</li><li><code>result::AbstractRAGResult</code>: The result containing the context and question to generate the answer for.</li><li><code>verbose::Integer</code>: If &gt;0, enables verbose logging.</li><li><code>api_kwargs::NamedTuple</code>: API parameters that will be forwarded to ALL of the API calls (<code>aiembed</code>, <code>aigenerate</code>, and <code>aiextract</code>).</li><li><code>contexter::AbstractContextBuilder</code>: The method to use for building the context. Defaults to <code>generator.contexter</code>, eg, <code>ContextEnumerator</code>.</li><li><code>contexter_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>contexter</code> call.</li><li><code>answerer::AbstractAnswerer</code>: The method to use for generating the answer. Defaults to <code>generator.answerer</code>, eg, <code>SimpleAnswerer</code>.</li><li><code>answerer_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>answerer</code> call. Examples:<ul><li><code>model</code>: The model to use for generating the answer. Defaults to <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: The template to use for the <code>aigenerate</code> function. Defaults to <code>:RAGAnswerFromContext</code>.</li></ul></li><li><code>refiner::AbstractRefiner</code>: The method to use for refining the answer. Defaults to <code>generator.refiner</code>, eg, <code>NoRefiner</code>.</li><li><code>refiner_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>refiner</code> call.<ul><li><code>model</code>: The model to use for generating the answer. Defaults to <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: The template to use for the <code>aigenerate</code> function. Defaults to <code>:RAGAnswerRefiner</code>.</li></ul></li><li><code>postprocessor::AbstractPostprocessor</code>: The method to use for postprocessing the answer. Defaults to <code>generator.postprocessor</code>, eg, <code>NoPostprocessor</code>.</li><li><code>postprocessor_kwargs::NamedTuple</code>: API parameters that will be forwarded to the <code>postprocessor</code> call.</li><li><code>cost_tracker</code>: An atomic counter to track the total cost of the operations.</li></ul><p>See also: <code>retrieve</code>, <code>build_context!</code>, <code>ContextEnumerator</code>, <code>answer!</code>, <code>SimpleAnswerer</code>, <code>refine!</code>, <code>NoRefiner</code>, <code>SimpleRefiner</code>, <code>postprocess!</code>, <code>NoPostprocessor</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">Assume we already have `index`

question = &quot;What are the best practices for parallel computing in Julia?&quot;

# Retrieve the relevant chunks - returns RAGResult
result = retrieve(index, question)

# Generate the answer using the default generator, mutates the same result
result = generate!(index, result)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L395-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_chunks-Tuple{RAGTools.AbstractChunker, Vector{&lt;:AbstractString}}" href="#RAGTools.get_chunks-Tuple{RAGTools.AbstractChunker, Vector{&lt;:AbstractString}}"><code>RAGTools.get_chunks</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_chunks(chunker::AbstractChunker,
    files_or_docs::Vector{&lt;:AbstractString};
    sources::AbstractVector{&lt;:AbstractString} = files_or_docs,
    verbose::Bool = true,
    separators = [&quot;\n\n&quot;, &quot;. &quot;, &quot;\n&quot;, &quot; &quot;], max_length::Int = 256)</code></pre><p>Chunks the provided <code>files_or_docs</code> into chunks of maximum length <code>max_length</code> (if possible with provided <code>separators</code>).</p><p>Supports two modes of operation:</p><ul><li><code>chunker = FileChunker()</code>: The function opens each file in <code>files_or_docs</code> and reads its contents.</li><li><code>chunker = TextChunker()</code>: The function assumes that <code>files_or_docs</code> is a vector of strings to be chunked, you MUST provide corresponding <code>sources</code>.</li></ul><p><strong>Arguments</strong></p><ul><li><code>files_or_docs</code>: A vector of valid file paths OR string documents to be chunked.</li><li><code>separators</code>: A list of strings used as separators for splitting the text in each file into chunks. Default is <code>[\n\n&quot;, &quot;. &quot;, &quot;\n&quot;, &quot; &quot;]</code>.  See <code>recursive_splitter</code> for more details.</li><li><code>max_length</code>: The maximum length of each chunk (if possible with provided separators). Default is 256.</li><li><code>sources</code>: A vector of strings indicating the source of each chunk. Default is equal to <code>files_or_docs</code> (for <code>reader=:files</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L167-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_embeddings-Tuple{RAGTools.BatchEmbedder, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.get_embeddings-Tuple{RAGTools.BatchEmbedder, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_embeddings(embedder::BatchEmbedder, docs::AbstractVector{&lt;:AbstractString};
    verbose::Bool = true,
    model::AbstractString = PT.MODEL_EMBEDDING,
    truncate_dimension::Union{Int, Nothing} = nothing,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    target_batch_size_length::Int = 80_000,
    ntasks::Int = 4 * Threads.nthreads(),
    kwargs...)</code></pre><p>Embeds a vector of <code>docs</code> using the provided model (kwarg <code>model</code>) in a batched manner - <code>BatchEmbedder</code>.</p><p><code>BatchEmbedder</code> tries to batch embedding calls for roughly 80K characters per call (to avoid exceeding the API rate limit) to reduce network latency.</p><p><strong>Notes</strong></p><ul><li><code>docs</code> are assumed to be already chunked to the reasonable sizes that fit within the embedding context limit.</li><li>If you get errors about exceeding input sizes, first check the <code>max_length</code> in your chunks.  If that does NOT resolve the issue, try reducing the <code>target_batch_size_length</code> parameter (eg, 10_000) and number of tasks <code>ntasks=1</code>.  Some providers cannot handle large batch sizes.</li></ul><p><strong>Arguments</strong></p><ul><li><code>docs</code>: A vector of strings to be embedded.</li><li><code>verbose</code>: A boolean flag for verbose output. Default is <code>true</code>.</li><li><code>model</code>: The model to use for embedding. Default is <code>PT.MODEL_EMBEDDING</code>.</li><li><code>truncate_dimension</code>: The dimensionality of the embeddings to truncate to. Default is <code>nothing</code>, <code>0</code> will also do nothing.</li><li><code>cost_tracker</code>: A <code>Threads.Atomic{Float64}</code> object to track the total cost of the API calls. Useful to pass the total cost to the parent call.</li><li><code>target_batch_size_length</code>: The target length (in characters) of each batch of document chunks sent for embedding. Default is 80_000 characters. Speeds up embedding process.</li><li><code>ntasks</code>: The number of tasks to use for asyncmap. Default is 4 * Threads.nthreads().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L227-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_embeddings-Tuple{RAGTools.BinaryBatchEmbedder, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.get_embeddings-Tuple{RAGTools.BinaryBatchEmbedder, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_embeddings(embedder::BinaryBatchEmbedder, docs::AbstractVector{&lt;:AbstractString};
    verbose::Bool = true,
    model::AbstractString = PT.MODEL_EMBEDDING,
    truncate_dimension::Union{Int, Nothing} = nothing,
    return_type::Type = Matrix{Bool},
    cost_tracker = Threads.Atomic{Float64}(0.0),
    target_batch_size_length::Int = 80_000,
    ntasks::Int = 4 * Threads.nthreads(),
    kwargs...)</code></pre><p>Embeds a vector of <code>docs</code> using the provided model (kwarg <code>model</code>) in a batched manner and then returns the binary embeddings matrix - <code>BinaryBatchEmbedder</code>.</p><p><code>BinaryBatchEmbedder</code> tries to batch embedding calls for roughly 80K characters per call (to avoid exceeding the API rate limit) to reduce network latency.</p><p><strong>Notes</strong></p><ul><li><code>docs</code> are assumed to be already chunked to the reasonable sizes that fit within the embedding context limit.</li><li>If you get errors about exceeding input sizes, first check the <code>max_length</code> in your chunks.  If that does NOT resolve the issue, try reducing the <code>target_batch_size_length</code> parameter (eg, 10_000) and number of tasks <code>ntasks=1</code>.  Some providers cannot handle large batch sizes.</li></ul><p><strong>Arguments</strong></p><ul><li><code>docs</code>: A vector of strings to be embedded.</li><li><code>verbose</code>: A boolean flag for verbose output. Default is <code>true</code>.</li><li><code>model</code>: The model to use for embedding. Default is <code>PT.MODEL_EMBEDDING</code>.</li><li><code>truncate_dimension</code>: The dimensionality of the embeddings to truncate to. Default is <code>nothing</code>.</li><li><code>return_type</code>: The type of the returned embeddings matrix. Default is <code>Matrix{Bool}</code>. Choose <code>BitMatrix</code> to minimize storage requirements, <code>Matrix{Bool}</code> to maximize performance in elementwise-ops.</li><li><code>cost_tracker</code>: A <code>Threads.Atomic{Float64}</code> object to track the total cost of the API calls. Useful to pass the total cost to the parent call.</li><li><code>target_batch_size_length</code>: The target length (in characters) of each batch of document chunks sent for embedding. Default is 80_000 characters. Speeds up embedding process.</li><li><code>ntasks</code>: The number of tasks to use for asyncmap. Default is 4 * Threads.nthreads().</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L296-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_embeddings-Tuple{RAGTools.BitPackedBatchEmbedder, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.get_embeddings-Tuple{RAGTools.BitPackedBatchEmbedder, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_embeddings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_embeddings(embedder::BitPackedBatchEmbedder, docs::AbstractVector{&lt;:AbstractString};
    verbose::Bool = true,
    model::AbstractString = PT.MODEL_EMBEDDING,
    truncate_dimension::Union{Int, Nothing} = nothing,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    target_batch_size_length::Int = 80_000,
    ntasks::Int = 4 * Threads.nthreads(),
    kwargs...)</code></pre><p>Embeds a vector of <code>docs</code> using the provided model (kwarg <code>model</code>) in a batched manner and then returns the binary embeddings matrix represented in UInt64 (bit-packed) - <code>BitPackedBatchEmbedder</code>.</p><p><code>BitPackedBatchEmbedder</code> tries to batch embedding calls for roughly 80K characters per call (to avoid exceeding the API rate limit) to reduce network latency.</p><p>The best option for FAST and MEMORY-EFFICIENT storage of embeddings, for retrieval use <code>BitPackedCosineSimilarity</code>.</p><p><strong>Notes</strong></p><ul><li><code>docs</code> are assumed to be already chunked to the reasonable sizes that fit within the embedding context limit.</li><li>If you get errors about exceeding input sizes, first check the <code>max_length</code> in your chunks.  If that does NOT resolve the issue, try reducing the <code>target_batch_size_length</code> parameter (eg, 10_000) and number of tasks <code>ntasks=1</code>.  Some providers cannot handle large batch sizes.</li></ul><p><strong>Arguments</strong></p><ul><li><code>docs</code>: A vector of strings to be embedded.</li><li><code>verbose</code>: A boolean flag for verbose output. Default is <code>true</code>.</li><li><code>model</code>: The model to use for embedding. Default is <code>PT.MODEL_EMBEDDING</code>.</li><li><code>truncate_dimension</code>: The dimensionality of the embeddings to truncate to. Default is <code>nothing</code>.</li><li><code>cost_tracker</code>: A <code>Threads.Atomic{Float64}</code> object to track the total cost of the API calls. Useful to pass the total cost to the parent call.</li><li><code>target_batch_size_length</code>: The target length (in characters) of each batch of document chunks sent for embedding. Default is 80_000 characters. Speeds up embedding process.</li><li><code>ntasks</code>: The number of tasks to use for asyncmap. Default is 4 * Threads.nthreads().</li></ul><p>See also: <code>unpack_bits</code>, <code>pack_bits</code>, <code>BitPackedCosineSimilarity</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L347-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_keywords-Tuple{RAGTools.KeywordsProcessor, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.get_keywords-Tuple{RAGTools.KeywordsProcessor, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_keywords</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_keywords(
    processor::KeywordsProcessor, docs::AbstractVector{&lt;:AbstractString};
    verbose::Bool = true,
    stemmer = nothing,
    stopwords::Set{String} = Set(STOPWORDS),
    return_keywords::Bool = false,
    min_length::Integer = 3,
    min_term_freq::Int = 1, max_terms::Int = typemax(Int),
    kwargs...)</code></pre><p>Generate a <code>DocumentTermMatrix</code> from a vector of <code>docs</code> using the provided <code>stemmer</code> and <code>stopwords</code>.</p><p><strong>Arguments</strong></p><ul><li><code>docs</code>: A vector of strings to be embedded.</li><li><code>verbose</code>: A boolean flag for verbose output. Default is <code>true</code>.</li><li><code>stemmer</code>: A stemmer to use for stemming. Default is <code>nothing</code>.</li><li><code>stopwords</code>: A set of stopwords to remove. Default is <code>Set(STOPWORDS)</code>.</li><li><code>return_keywords</code>: A boolean flag for returning the keywords. Default is <code>false</code>. Useful for query processing in search time.</li><li><code>min_length</code>: The minimum length of the keywords. Default is <code>3</code>.</li><li><code>min_term_freq</code>: The minimum frequency a term must have to be included in the vocabulary, eg, <code>min_term_freq = 2</code> means only terms that appear at least twice will be included.</li><li><code>max_terms</code>: The maximum number of terms to include in the vocabulary, eg, <code>max_terms = 100</code> means only the 100 most frequent terms will be included.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L412-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_tags-Tuple{RAGTools.NoTagger, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.get_tags-Tuple{RAGTools.NoTagger, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_tags(tagger::NoTagger, docs::AbstractVector{&lt;:AbstractString};
    kwargs...)</code></pre><p>Simple no-op that skips any tagging of the documents</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L486-L491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_tags-Tuple{RAGTools.OpenTagger, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.get_tags-Tuple{RAGTools.OpenTagger, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_tags(tagger::OpenTagger, docs::AbstractVector{&lt;:AbstractString};
    verbose::Bool = true,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Extracts &quot;tags&quot; (metadata/keywords) from a vector of <code>docs</code> using the provided model (kwarg <code>model</code>).</p><p><strong>Arguments</strong></p><ul><li><code>docs</code>: A vector of strings to be embedded.</li><li><code>verbose</code>: A boolean flag for verbose output. Default is <code>true</code>.</li><li><code>model</code>: The model to use for tags extraction. Default is <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: A template to be used for tags extraction. Default is <code>:RAGExtractMetadataShort</code>.</li><li><code>cost_tracker</code>: A <code>Threads.Atomic{Float64}</code> object to track the total cost of the API calls. Useful to pass the total cost to the parent call.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L512-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.get_tags-Tuple{RAGTools.PassthroughTagger, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.get_tags-Tuple{RAGTools.PassthroughTagger, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.get_tags</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_tags(tagger::PassthroughTagger, docs::AbstractVector{&lt;:AbstractString};
    tags::AbstractVector{&lt;:AbstractVector{&lt;:AbstractString}},
    kwargs...)</code></pre><p>Pass <code>tags</code> directly as Vector of Vectors of strings (ie, <code>tags[i]</code> is the tags for <code>docs[i]</code>). It then builds the vocabulary from the tags and returns both the tags in matrix form and the vocabulary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L497-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.getpropertynested" href="#RAGTools.getpropertynested"><code>RAGTools.getpropertynested</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getpropertynested(
    nt::NamedTuple, parent_keys::Vector{Symbol}, key::Symbol, default = nothing)</code></pre><p>Get a property <code>key</code> from a nested NamedTuple <code>nt</code>, where the property is nested to a key in <code>parent_keys</code>.</p><p>Useful for nested kwargs where we want to get some property in <code>parent_keys</code> subset (eg, <code>model</code> in <code>retriever_kwargs</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">kw = (; abc = (; def = &quot;x&quot;))
getpropertynested(kw, [:abc], :def)
# Output: &quot;x&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L543-L557">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.hamming_distance-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Integer" href="#RAGTools.hamming_distance-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}}} where T&lt;:Integer"><code>RAGTools.hamming_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hamming_distance(
    mat::AbstractMatrix{T}, query::AbstractVector{T})::Vector{Int} where {T &lt;: Integer}</code></pre><p>Calculates the column-wise Hamming distance between a matrix of binary vectors <code>mat</code> and a single binary vector <code>vect</code>.</p><p>This is the first-pass ranking for <code>BinaryCosineSimilarity</code> method.</p><p>Implementation from <a href="https://github.com/domluna/tinyRAG"><strong>domluna&#39;s tinyRAG</strong></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L344-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.hcat_truncate-Union{Tuple{AbstractVector{&lt;:AbstractMatrix{T}}}, Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, Union{Nothing, Int64}}} where T&lt;:Real" href="#RAGTools.hcat_truncate-Union{Tuple{AbstractVector{&lt;:AbstractMatrix{T}}}, Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, Union{Nothing, Int64}}} where T&lt;:Real"><code>RAGTools.hcat_truncate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hcat_truncate(matrices::AbstractVector{&lt;:AbstractMatrix{T}},
    truncate_dimension::Union{Nothing, Int} = nothing; verbose::Bool = false) where {T &lt;:
                                                                                     Real}</code></pre><p>Horizontal concatenation of matrices, with optional truncation of the rows of each matrix to the specified dimension (reducing embedding dimensionality).</p><p>More efficient that a simple splatting, as the resulting matrix is pre-allocated in one go.</p><p>Returns: a <code>Matrix{Float32}</code></p><p><strong>Arguments</strong></p><ul><li><code>matrices::AbstractVector{&lt;:AbstractMatrix{T}}</code>: Vector of matrices to concatenate</li><li><code>truncate_dimension::Union{Nothing,Int}=nothing</code>: Dimension to truncate to, or <code>nothing</code> or <code>0</code> to skip truncation. If truncated, the columns will be normalized.</li><li><code>verbose::Bool=false</code>: Whether to print verbose output.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">a = rand(Float32, 1000, 10)
b = rand(Float32, 1000, 20)

c = hcat_truncate([a, b])
size(c) # (1000, 30)

d = hcat_truncate([a, b], 500)
size(d) # (500, 30)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L48-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.load_text-Tuple{RAGTools.AbstractChunker, Any}" href="#RAGTools.load_text-Tuple{RAGTools.AbstractChunker, Any}"><code>RAGTools.load_text</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_text(chunker::AbstractChunker, input;
    kwargs...)</code></pre><p>Load text from <code>input</code> using the provided <code>chunker</code>. Called by <code>get_chunks</code>.</p><p>Available chunkers:</p><ul><li><code>FileChunker</code>: The function opens each file in <code>input</code> and reads its contents.</li><li><code>TextChunker</code>: The function assumes that <code>input</code> is a vector of strings to be chunked, you MUST provide corresponding <code>sources</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L142-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.max_bm25_score-Tuple{RAGTools.AbstractDocumentTermMatrix, AbstractVector{&lt;:AbstractString}}" href="#RAGTools.max_bm25_score-Tuple{RAGTools.AbstractDocumentTermMatrix, AbstractVector{&lt;:AbstractString}}"><code>RAGTools.max_bm25_score</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>max<em>bm25</em>score(     dtm::AbstractDocumentTermMatrix, query<em>tokens::AbstractVector{&lt;:AbstractString};     k1::Float32 = 1.2f0, b::Float32 = 0.75f0, max</em>tf::Real = 3,     min<em>doc</em>rel_length::Float32 = 0.5f0)</p><p>Returns the maximum BM25 score that can be achieved for a given query (assuming the <code>max_tf</code> matches and the <code>min_doc_rel_length</code> being the smallest document relative length). Good for normalizing BM25 scores.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">max_score = max_bm25_score(chunkdata(key_index), query_tokens)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/bm25.jl#L194-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.merge_kwargs_nested-Tuple{NamedTuple, NamedTuple}" href="#RAGTools.merge_kwargs_nested-Tuple{NamedTuple, NamedTuple}"><code>RAGTools.merge_kwargs_nested</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">merge_kwargs_nested(nt1::NamedTuple, nt2::NamedTuple)</code></pre><p>Merges two nested NamedTuples <code>nt1</code> and <code>nt2</code> recursively. The <code>nt2</code> values will overwrite the <code>nt1</code> values when overlapping.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kw = (; abc = (; def = &quot;x&quot;))
kw2 = (; abc = (; def = &quot;x&quot;, def2 = 2), new = 1)
merge_kwargs_nested(kw, kw2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L576-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.pack_bits-Tuple{AbstractMatrix{&lt;:Bool}}" href="#RAGTools.pack_bits-Tuple{AbstractMatrix{&lt;:Bool}}"><code>RAGTools.pack_bits</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pack_bits(arr::AbstractMatrix{&lt;:Bool}) -&gt; Matrix{UInt64}
pack_bits(vect::AbstractVector{&lt;:Bool}) -&gt; Vector{UInt64}</code></pre><p>Pack a matrix or vector of boolean values into a more compact representation using UInt64.</p><p><strong>Arguments (Input)</strong></p><ul><li><code>arr::AbstractMatrix{&lt;:Bool}</code>: A matrix of boolean values where the number of rows must be divisible by 64.</li></ul><p><strong>Returns</strong></p><ul><li>For <code>arr::AbstractMatrix{&lt;:Bool}</code>: Returns a matrix of UInt64 where each element represents 64 boolean values from the original matrix.</li></ul><p><strong>Examples</strong></p><p>For vectors:</p><pre><code class="language-julia hljs">bin = rand(Bool, 128)
binint = pack_bits(bin)
binx = unpack_bits(binint)
@assert bin == binx</code></pre><p>For matrices:</p><pre><code class="language-julia hljs">bin = rand(Bool, 128, 10)
binint = pack_bits(bin)
binx = unpack_bits(binint)
@assert bin == binx</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L611-L640">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.permutation_step!-Tuple{RAGTools.RankGPTResult}" href="#RAGTools.permutation_step!-Tuple{RAGTools.RankGPTResult}"><code>RAGTools.permutation_step!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">permutation_step!(
    result::RankGPTResult; rank_start::Integer = 1, rank_end::Integer = 100, kwargs...)</code></pre><p>One sub-step of the RankGPT algorithm permutation ranking within the window of chunks defined by <code>rank_start</code> and <code>rank_end</code> positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rank_gpt.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.preprocess_tokens" href="#RAGTools.preprocess_tokens"><code>RAGTools.preprocess_tokens</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">preprocess_tokens(text::AbstractString, stemmer=nothing; stopwords::Union{Nothing,Set{String}}=nothing, min_length::Int=3)</code></pre><p>Preprocess provided <code>text</code> by removing numbers, punctuation, and applying stemming for BM25 search index.</p><p>Returns a list of preprocessed tokens.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">stemmer = Snowball.Stemmer(&quot;english&quot;)
stopwords = Set([&quot;a&quot;, &quot;an&quot;, &quot;and&quot;, &quot;are&quot;, &quot;as&quot;, &quot;at&quot;, &quot;be&quot;, &quot;but&quot;, &quot;by&quot;, &quot;for&quot;, &quot;if&quot;, &quot;in&quot;, &quot;into&quot;, &quot;is&quot;, &quot;it&quot;, &quot;no&quot;, &quot;not&quot;, &quot;of&quot;, &quot;on&quot;, &quot;or&quot;, &quot;such&quot;, &quot;some&quot;, &quot;that&quot;, &quot;the&quot;, &quot;their&quot;, &quot;then&quot;, &quot;there&quot;, &quot;these&quot;, &quot;they&quot;, &quot;this&quot;, &quot;to&quot;, &quot;was&quot;, &quot;will&quot;, &quot;with&quot;])
text = &quot;This is a sample paragraph to test the functionality of your text preprocessor. It contains a mix of uppercase and lowercase letters, as well as punctuation marks such as commas, periods, and exclamation points! Let&#39;s see how your preprocessor handles quotes, like &quot;this one&quot;, and also apostrophes, like in don&#39;t. Will it preserve the formatting of this paragraph, including the indentation and line breaks?&quot;
preprocess_tokens(text, stemmer; stopwords)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L436-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.print_html-Tuple{IO, RAGTools.AbstractAnnotatedNode}" href="#RAGTools.print_html-Tuple{IO, RAGTools.AbstractAnnotatedNode}"><code>RAGTools.print_html</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">print_html([io::IO,] parent_node::AbstractAnnotatedNode)

print_html([io::IO,] rag::AbstractRAGResult; add_sources::Bool = false,
    add_scores::Bool = false, default_styler = HTMLStyler(),
    low_styler = HTMLStyler(styles = &quot;color:magenta&quot;, classes = &quot;&quot;),
    medium_styler = HTMLStyler(styles = &quot;color:blue&quot;, classes = &quot;&quot;),
    high_styler = HTMLStyler(styles = &quot;&quot;, classes = &quot;&quot;), styler_kwargs...)</code></pre><p>Pretty-prints the annotation <code>parent_node</code> (or <code>RAGResult</code>) to the <code>io</code> stream (or returns the string) in HTML format (assumes node is styled with styler <code>HTMLStyler</code>).</p><p>It wraps each &quot;token&quot; into a span with requested styling (HTMLStyler&#39;s properties <code>classes</code> and <code>styles</code>). It also replaces new lines with <code>&lt;br&gt;</code> for better HTML formatting.</p><p>For any non-HTML styler, it prints the content as plain text.</p><p><strong>Returns</strong></p><ul><li><code>nothing</code> if <code>io</code> is provided</li><li>or the string with HTML-formatted text (if <code>io</code> is not provided, we print the result out)</li></ul><p>See also <code>HTMLStyler</code>, <code>annotate_support</code>, and <code>set_node_style!</code> for how the styling is applied and what the arguments mean.</p><p><strong>Examples</strong></p><p>Note: <code>RT</code> is an alias for <code>PromptingTools.Experimental.RAGTools</code></p><p>Simple start directly with the <code>RAGResult</code>:</p><pre><code class="language-julia hljs"># set up the text/RAGResult
context = [
    &quot;This is a test context.&quot;, &quot;Another context sentence.&quot;, &quot;Final piece of context.&quot;]
answer = &quot;This is a test answer. It has multiple sentences.&quot;
rag = RT.RAGResult(; context, final_answer=answer, question=&quot;&quot;)

# print the HTML
print_html(rag)</code></pre><p>Low-level control by creating our <code>AnnotatedNode</code>:</p><pre><code class="language-julia hljs"># prepare your HTML styling
styler_kwargs = (;
    default_styler=RT.HTMLStyler(),
    low_styler=RT.HTMLStyler(styles=&quot;color:magenta&quot;, classes=&quot;&quot;),
    medium_styler=RT.HTMLStyler(styles=&quot;color:blue&quot;, classes=&quot;&quot;),
    high_styler=RT.HTMLStyler(styles=&quot;&quot;, classes=&quot;&quot;))

# annotate the text
context = [
    &quot;This is a test context.&quot;, &quot;Another context sentence.&quot;, &quot;Final piece of context.&quot;]
answer = &quot;This is a test answer. It has multiple sentences.&quot;

parent_node = RT.annotate_support(
    RT.TrigramAnnotater(), answer, context; add_sources=false, add_scores=false, styler_kwargs...)

# print the HTML
print_html(parent_node)

# or to accumulate more nodes
io = IOBuffer()
print_html(io, parent_node)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L541-L602">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.rank_gpt-Tuple{AbstractVector{&lt;:AbstractString}, AbstractString}" href="#RAGTools.rank_gpt-Tuple{AbstractVector{&lt;:AbstractString}, AbstractString}"><code>RAGTools.rank_gpt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank_gpt(chunks::AbstractVector{&lt;:AbstractString}, question::AbstractString;
    verbose::Int = 1, rank_start::Integer = 1, rank_end::Integer = 100,
    window_size::Integer = 20, step::Integer = 10,
    num_rounds::Integer = 1, model::String = &quot;gpt4o&quot;, kwargs...)</code></pre><p>Ranks the <code>chunks</code> based on their relevance for <code>question</code>. Returns the ranking permutation of the chunks in the order they are most relevant to the question (the first is the most relevant).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = rank_gpt(chunks, question; rank_start=1, rank_end=25, window_size=8, step=4, num_rounds=3, model=&quot;gpt4o&quot;)</code></pre><p><strong>Reference</strong></p><p>[1] <a href="https://arxiv.org/abs/2304.09542">Is ChatGPT Good at Search? Investigating Large Language Models as Re-Ranking Agents by W. Sun et al.</a> [2] <a href="https://github.com/sunnweiwei/RankGPT">RankGPT Github</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rank_gpt.jl#L142-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.rank_sliding_window!-Tuple{RAGTools.RankGPTResult}" href="#RAGTools.rank_sliding_window!-Tuple{RAGTools.RankGPTResult}"><code>RAGTools.rank_sliding_window!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank_sliding_window!(
    result::RankGPTResult; verbose::Int = 1, rank_start = 1, rank_end = 100,
    window_size = 20, step = 10, model::String = &quot;gpt4o&quot;, kwargs...)</code></pre><p>One single pass of the RankGPT algorithm permutation ranking across all positions between <code>rank_start</code> and <code>rank_end</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rank_gpt.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.receive_permutation!-Tuple{AbstractVector{&lt;:Integer}, AbstractString}" href="#RAGTools.receive_permutation!-Tuple{AbstractVector{&lt;:Integer}, AbstractString}"><code>RAGTools.receive_permutation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">receive_permutation!(
    curr_rank::AbstractVector{&lt;:Integer}, response::AbstractString;
    rank_start::Integer = 1, rank_end::Integer = 100)</code></pre><p>Extracts and heals the permutation to contain all ranking positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/rank_gpt.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.reciprocal_rank_fusion-Tuple" href="#RAGTools.reciprocal_rank_fusion-Tuple"><code>RAGTools.reciprocal_rank_fusion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reciprocal_rank_fusion(args...; k::Int=60)</code></pre><p>Merges multiple rankings and calculates the reciprocal rank score for each chunk (discounted by the inverse of the rank).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">positions1 = [1, 3, 5, 7, 9]
positions2 = [2, 4, 6, 8, 10]
positions3 = [2, 4, 6, 11, 12]

merged_positions, scores = reciprocal_rank_fusion(positions1, positions2, positions3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L714-L727">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.reciprocal_rank_fusion-Union{Tuple{T}, Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:T}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:T}}} where T&lt;:Real" href="#RAGTools.reciprocal_rank_fusion-Union{Tuple{T}, Tuple{AbstractVector{&lt;:Integer}, AbstractVector{&lt;:T}, AbstractVector{&lt;:Integer}, AbstractVector{&lt;:T}}} where T&lt;:Real"><code>RAGTools.reciprocal_rank_fusion</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reciprocal_rank_fusion(
    positions1::AbstractVector{&lt;:Integer}, scores1::AbstractVector{&lt;:T},
    positions2::AbstractVector{&lt;:Integer},
    scores2::AbstractVector{&lt;:T}; k::Int = 60) where {T &lt;: Real}</code></pre><p>Merges two sets of rankings and their joint scores. Calculates the reciprocal rank score for each chunk (discounted by the inverse of the rank).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">positions1 = [1, 3, 5, 7, 9]
scores1 = [0.9, 0.8, 0.7, 0.6, 0.5]
positions2 = [2, 4, 6, 8, 10]
scores2 = [0.5, 0.6, 0.7, 0.8, 0.9]

merged, scores = reciprocal_rank_fusion(positions1, scores1, positions2, scores2; k = 60)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L743-L760">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.refine!-Tuple{RAGTools.NoRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}" href="#RAGTools.refine!-Tuple{RAGTools.NoRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.refine!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine!(
    refiner::NoRefiner, index::AbstractChunkIndex, result::AbstractRAGResult;
    kwargs...)</code></pre><p>Simple no-op function for <code>refine!</code>. It simply copies the <code>result.answer</code> and <code>result.conversations[:answer]</code> without any changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L170-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.refine!-Tuple{RAGTools.SimpleRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}" href="#RAGTools.refine!-Tuple{RAGTools.SimpleRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.refine!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine!(
    refiner::SimpleRefiner, index::AbstractDocumentIndex, result::AbstractRAGResult;
    verbose::Bool = true,
    model::AbstractString = PT.MODEL_CHAT,
    template::Symbol = :RAGAnswerRefiner,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Give model a chance to refine the answer (using the same or different context than previously provided).</p><p>This method uses the same context as the original answer, however, it can be modified to do additional retrieval and use a different context.</p><p><strong>Returns</strong></p><ul><li>Mutated <code>result</code> with <code>result.final_answer</code> and the full conversation saved in <code>result.conversations[:final_answer]</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>refiner::SimpleRefiner</code>: The method to use for refining the answer. Uses <code>aigenerate</code>.</li><li><code>index::AbstractDocumentIndex</code>: The index containing chunks and sources.</li><li><code>result::AbstractRAGResult</code>: The result containing the context and question to generate the answer for.</li><li><code>model::AbstractString</code>: The model to use for generating the answer. Defaults to <code>PT.MODEL_CHAT</code>.</li><li><code>verbose::Bool</code>: If <code>true</code>, enables verbose logging.</li><li><code>template::Symbol</code>: The template to use for the <code>aigenerate</code> function. Defaults to <code>:RAGAnswerRefiner</code>.</li><li><code>cost_tracker</code>: An atomic counter to track the cost of the operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L187-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.refine!-Tuple{RAGTools.TavilySearchRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}" href="#RAGTools.refine!-Tuple{RAGTools.TavilySearchRefiner, RAGTools.AbstractDocumentIndex, RAGTools.AbstractRAGResult}"><code>RAGTools.refine!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">refine!(
    refiner::TavilySearchRefiner, index::AbstractDocumentIndex, result::AbstractRAGResult;
    verbose::Bool = true,
    model::AbstractString = PT.MODEL_CHAT,
    include_answer::Bool = true,
    max_results::Integer = 5,
    include_domains::AbstractVector{&lt;:AbstractString} = String[],
    exclude_domains::AbstractVector{&lt;:AbstractString} = String[],
    template::Symbol = :RAGWebSearchRefiner,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Refines the answer by executing a web search using the Tavily API. This method aims to enhance the answer&#39;s accuracy and relevance by incorporating information retrieved from the web.</p><p>Note: The web results and web answer (if requested) will be added to the context and sources!</p><p><strong>Returns</strong></p><ul><li>Mutated <code>result</code> with <code>result.final_answer</code> and the full conversation saved in <code>result.conversations[:final_answer]</code>.</li><li>In addition, the web results and web answer (if requested) are appended to the <code>result.context</code> and <code>result.sources</code> for correct highlighting and verification.</li></ul><p><strong>Arguments</strong></p><ul><li><code>refiner::TavilySearchRefiner</code>: The method to use for refining the answer. Uses <code>aigenerate</code> with a web search template.</li><li><code>index::AbstractDocumentIndex</code>: The index containing chunks and sources.</li><li><code>result::AbstractRAGResult</code>: The result containing the context and question to generate the answer for.</li><li><code>model::AbstractString</code>: The model to use for generating the answer. Defaults to <code>PT.MODEL_CHAT</code>.</li><li><code>include_answer::Bool</code>: If <code>true</code>, includes the answer from Tavily in the web search.</li><li><code>max_results::Integer</code>: The maximum number of results to return.</li><li><code>include_domains::AbstractVector{&lt;:AbstractString}</code>: A list of domains to include in the search results. Default is an empty list.</li><li><code>exclude_domains::AbstractVector{&lt;:AbstractString}</code>: A list of domains to exclude from the search results. Default is an empty list.</li><li><code>verbose::Bool</code>: If <code>true</code>, enables verbose logging.</li><li><code>template::Symbol</code>: The template to use for the <code>aigenerate</code> function. Defaults to <code>:RAGWebSearchRefiner</code>.</li><li><code>cost_tracker</code>: An atomic counter to track the cost of the operation.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">refiner!(TavilySearchRefiner(), index, result)
# See result.final_answer or pprint(result)</code></pre><p>To enable this refiner in a full RAG pipeline, simply swap the component in the config:</p><pre><code class="language-julia hljs">cfg = RT.RAGConfig()
cfg.generator.refiner = RT.TavilySearchRefiner()

result = airag(cfg, index; question, return_all = true)
pprint(result)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/generation.jl#L241-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.rephrase-Tuple{RAGTools.HyDERephraser, AbstractString}" href="#RAGTools.rephrase-Tuple{RAGTools.HyDERephraser, AbstractString}"><code>RAGTools.rephrase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rephrase(rephraser::SimpleRephraser, question::AbstractString;
    verbose::Bool = true,
    model::String = PT.MODEL_CHAT, template::Symbol = :RAGQueryHyDE,
    cost_tracker = Threads.Atomic{Float64}(0.0))</code></pre><p>Rephrases the <code>question</code> using the provided rephraser <code>template = RAGQueryHyDE</code>.</p><p>Special flavor of rephrasing using HyDE (Hypothetical Document Embedding) method,  which aims to find the documents most similar to a synthetic passage that <em>would be</em> a good answer to our question.</p><p>Returns both the original and the rephrased question.</p><p><strong>Arguments</strong></p><ul><li><code>rephraser</code>: Type that dictates the logic of rephrasing step.</li><li><code>question</code>: The question to be rephrased.</li><li><code>model</code>: The model to use for rephrasing. Default is <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: The rephrasing template to use. Default is <code>:RAGQueryHyDE</code>. Find more with <code>aitemplates(&quot;rephrase&quot;)</code>.</li><li><code>verbose</code>: A boolean flag indicating whether to print verbose logging. Default is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L150-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.rephrase-Tuple{RAGTools.NoRephraser, AbstractString}" href="#RAGTools.rephrase-Tuple{RAGTools.NoRephraser, AbstractString}"><code>RAGTools.rephrase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rephrase(rephraser::NoRephraser, question::AbstractString; kwargs...)</code></pre><p>No-op, simple passthrough.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.rephrase-Tuple{RAGTools.SimpleRephraser, AbstractString}" href="#RAGTools.rephrase-Tuple{RAGTools.SimpleRephraser, AbstractString}"><code>RAGTools.rephrase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rephrase(rephraser::SimpleRephraser, question::AbstractString;
    verbose::Bool = true,
    model::String = PT.MODEL_CHAT, template::Symbol = :RAGQueryOptimizer,
    cost_tracker = Threads.Atomic{Float64}(0.0), kwargs...)</code></pre><p>Rephrases the <code>question</code> using the provided rephraser <code>template</code>.</p><p>Returns both the original and the rephrased question.</p><p><strong>Arguments</strong></p><ul><li><code>rephraser</code>: Type that dictates the logic of rephrasing step.</li><li><code>question</code>: The question to be rephrased.</li><li><code>model</code>: The model to use for rephrasing. Default is <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: The rephrasing template to use. Default is <code>:RAGQueryOptimizer</code>. Find more with <code>aitemplates(&quot;rephrase&quot;)</code>.</li><li><code>verbose</code>: A boolean flag indicating whether to print verbose logging. Default is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L119-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.rerank-Tuple{RAGTools.CohereReranker, RAGTools.AbstractDocumentIndex, AbstractString, RAGTools.AbstractCandidateChunks}" href="#RAGTools.rerank-Tuple{RAGTools.CohereReranker, RAGTools.AbstractDocumentIndex, AbstractString, RAGTools.AbstractCandidateChunks}"><code>RAGTools.rerank</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rerank(
    reranker::CohereReranker, index::AbstractDocumentIndex, question::AbstractString,
    candidates::AbstractCandidateChunks;
    verbose::Bool = false,
    api_key::AbstractString = PT.COHERE_API_KEY,
    top_n::Integer = length(candidates.scores),
    model::AbstractString = &quot;rerank-english-v3.0&quot;,
    return_documents::Bool = false,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Re-ranks a list of candidate chunks using the Cohere Rerank API. See https://cohere.com/rerank for more details. </p><p><strong>Arguments</strong></p><ul><li><code>reranker</code>: Using Cohere API</li><li><code>index</code>: The index that holds the underlying chunks to be re-ranked.</li><li><code>question</code>: The query to be used for the search.</li><li><code>candidates</code>: The candidate chunks to be re-ranked.</li><li><code>top_n</code>: The number of most relevant documents to return. Default is <code>length(documents)</code>.</li><li><code>model</code>: The model to use for reranking. Default is <code>rerank-english-v3.0</code>.</li><li><code>return_documents</code>: A boolean flag indicating whether to return the reranked documents in the response. Default is <code>false</code>.</li><li><code>verbose</code>: A boolean flag indicating whether to print verbose logging. Default is <code>false</code>.</li><li><code>cost_tracker</code>: An atomic counter to track the cost of the retrieval. Not implemented /tracked (cost unclear). Provided for consistency.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L687-L713">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.rerank-Tuple{RAGTools.RankGPTReranker, RAGTools.AbstractDocumentIndex, AbstractString, RAGTools.AbstractCandidateChunks}" href="#RAGTools.rerank-Tuple{RAGTools.RankGPTReranker, RAGTools.AbstractDocumentIndex, AbstractString, RAGTools.AbstractCandidateChunks}"><code>RAGTools.rerank</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rerank(
    reranker::RankGPTReranker, index::AbstractDocumentIndex, question::AbstractString,
    candidates::AbstractCandidateChunks;
    api_key::AbstractString = PT.OPENAI_API_KEY,
    model::AbstractString = PT.MODEL_CHAT,
    verbose::Bool = false,
    top_n::Integer = length(candidates.scores),
    unique_chunks::Bool = true,
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Re-ranks a list of candidate chunks using the RankGPT algorithm. See https://github.com/sunnweiwei/RankGPT for more details. </p><p>It uses LLM calls to rank the candidate chunks.</p><p><strong>Arguments</strong></p><ul><li><code>reranker</code>: Using Cohere API</li><li><code>index</code>: The index that holds the underlying chunks to be re-ranked.</li><li><code>question</code>: The query to be used for the search.</li><li><code>candidates</code>: The candidate chunks to be re-ranked.</li><li><code>top_n</code>: The number of most relevant documents to return. Default is <code>length(documents)</code>.</li><li><code>model</code>: The model to use for reranking. Default is <code>rerank-english-v3.0</code>.</li><li><code>verbose</code>: A boolean flag indicating whether to print verbose logging. Default is <code>1</code>.</li><li><code>unique_chunks</code>: A boolean flag indicating whether to remove duplicates from the candidate chunks prior to reranking (saves compute time). Default is <code>true</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">index = &lt;some index&gt;
question = &quot;What are the best practices for parallel computing in Julia?&quot;

cfg = RAGConfig(; retriever = SimpleRetriever(; reranker = RT.RankGPTReranker()))
msg = airag(cfg, index; question, return_all = true)</code></pre><p>To get full verbosity of logs, set <code>verbose = 5</code> (anything higher than 3).</p><pre><code class="language-julia hljs">msg = airag(cfg, index; question, return_all = true, verbose = 5)</code></pre><p><strong>Reference</strong></p><p>[1] <a href="https://arxiv.org/abs/2304.09542">Is ChatGPT Good at Search? Investigating Large Language Models as Re-Ranking Agents by W. Sun et al.</a> [2] <a href="https://github.com/sunnweiwei/RankGPT">RankGPT Github</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L774-L818">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.retrieve-Tuple{RAGTools.AbstractRetriever, RAGTools.AbstractDocumentIndex, AbstractString}" href="#RAGTools.retrieve-Tuple{RAGTools.AbstractRetriever, RAGTools.AbstractDocumentIndex, AbstractString}"><code>RAGTools.retrieve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">retrieve(retriever::AbstractRetriever,
    index::AbstractChunkIndex,
    question::AbstractString;
    verbose::Integer = 1,
    top_k::Integer = 100,
    top_n::Integer = 5,
    api_kwargs::NamedTuple = NamedTuple(),
    rephraser::AbstractRephraser = retriever.rephraser,
    rephraser_kwargs::NamedTuple = NamedTuple(),
    embedder::AbstractEmbedder = retriever.embedder,
    embedder_kwargs::NamedTuple = NamedTuple(),
    processor::AbstractProcessor = retriever.processor,
    processor_kwargs::NamedTuple = NamedTuple(),
    finder::AbstractSimilarityFinder = retriever.finder,
    finder_kwargs::NamedTuple = NamedTuple(),
    tagger::AbstractTagger = retriever.tagger,
    tagger_kwargs::NamedTuple = NamedTuple(),
    filter::AbstractTagFilter = retriever.filter,
    filter_kwargs::NamedTuple = NamedTuple(),
    reranker::AbstractReranker = retriever.reranker,
    reranker_kwargs::NamedTuple = NamedTuple(),
    cost_tracker = Threads.Atomic{Float64}(0.0),
    kwargs...)</code></pre><p>Retrieves the most relevant chunks from the index for the given question and returns them in the <code>RAGResult</code> object.</p><p>This is the main entry point for the retrieval stage of the RAG pipeline. It is often followed by <code>generate!</code> step.</p><p>Notes:</p><ul><li>The default flow is <code>build_context!</code> -&gt; <code>answer!</code> -&gt; <code>refine!</code> -&gt; <code>postprocess!</code>.</li></ul><p>The arguments correspond to the steps of the retrieval process (rephrasing, embedding, finding similar docs, tagging, filtering by tags, reranking). You can customize each step by providing a new custom type that dispatches the corresponding function,      eg, create your own type <code>struct MyReranker&lt;:AbstractReranker end</code> and define the custom method for it <code>rerank(::MyReranker,...) = ...</code>.</p><p>Note: Discover available retrieval sub-types for each step with <code>subtypes(AbstractRephraser)</code> and similar for other abstract types.</p><p>If you&#39;re using locally-hosted models, you can pass the <code>api_kwargs</code> with the <code>url</code> field set to the model&#39;s URL and make sure to provide corresponding      <code>model</code> kwargs to <code>rephraser</code>, <code>embedder</code>, and <code>tagger</code> to use the custom models (they make AI calls).</p><p><strong>Arguments</strong></p><ul><li><code>retriever</code>: The retrieval method to use. Default is <code>SimpleRetriever</code> but could be <code>AdvancedRetriever</code> for more advanced retrieval.</li><li><code>index</code>: The index that holds the chunks and sources to be retrieved from.</li><li><code>question</code>: The question to be used for the retrieval.</li><li><code>verbose</code>: If <code>&gt;0</code>, it prints out verbose logging. Default is <code>1</code>. If you set it to <code>2</code>, it will print out logs for each sub-function.</li><li><code>top_k</code>: The TOTAL number of closest chunks to return from <code>find_closest</code>. Default is <code>100</code>.  If there are multiple rephrased questions, the number of chunks per each item will be <code>top_k ÷ number_of_rephrased_questions</code>.</li><li><code>top_n</code>: The TOTAL number of most relevant chunks to return for the context (from <code>rerank</code> step). Default is <code>5</code>.</li><li><code>api_kwargs</code>: Additional keyword arguments to be passed to the API calls (shared by all <code>ai*</code> calls).</li><li><code>rephraser</code>: Transform the question into one or more questions. Default is <code>retriever.rephraser</code>.</li><li><code>rephraser_kwargs</code>: Additional keyword arguments to be passed to the rephraser.<ul><li><code>model</code>: The model to use for rephrasing. Default is <code>PT.MODEL_CHAT</code>.</li><li><code>template</code>: The rephrasing template to use. Default is <code>:RAGQueryOptimizer</code> or <code>:RAGQueryHyDE</code> (depending on the <code>rephraser</code> selected).</li></ul></li><li><code>embedder</code>: The embedding method to use. Default is <code>retriever.embedder</code>.</li><li><code>embedder_kwargs</code>: Additional keyword arguments to be passed to the embedder.</li><li><code>processor</code>: The processor method to use when using Keyword-based index. Default is <code>retriever.processor</code>.</li><li><code>processor_kwargs</code>: Additional keyword arguments to be passed to the processor.</li><li><code>finder</code>: The similarity search method to use. Default is <code>retriever.finder</code>, often <code>CosineSimilarity</code>.</li><li><code>finder_kwargs</code>: Additional keyword arguments to be passed to the similarity finder.</li><li><code>tagger</code>: The tag generating method to use. Default is <code>retriever.tagger</code>.</li><li><code>tagger_kwargs</code>: Additional keyword arguments to be passed to the tagger. Noteworthy arguments:<ul><li><code>tags</code>: Directly provide the tags to use for filtering (can be String, Regex, or Vector{String}). Useful for <code>tagger = PassthroughTagger</code>.</li></ul></li><li><code>filter</code>: The tag matching method to use. Default is <code>retriever.filter</code>.</li><li><code>filter_kwargs</code>: Additional keyword arguments to be passed to the tag filter.</li><li><code>reranker</code>: The reranking method to use. Default is <code>retriever.reranker</code>.</li><li><code>reranker_kwargs</code>: Additional keyword arguments to be passed to the reranker.<ul><li><code>model</code>: The model to use for reranking. Default is <code>rerank-english-v2.0</code> if you use <code>reranker = CohereReranker()</code>.</li></ul></li><li><code>cost_tracker</code>: An atomic counter to track the cost of the retrieval. Default is <code>Threads.Atomic{Float64}(0.0)</code>.</li></ul><p>See also: <code>SimpleRetriever</code>, <code>AdvancedRetriever</code>, <code>build_index</code>, <code>rephrase</code>, <code>get_embeddings</code>, <code>get_keywords</code>, <code>find_closest</code>, <code>get_tags</code>, <code>find_tags</code>, <code>rerank</code>, <code>RAGResult</code>.</p><p><strong>Examples</strong></p><p>Find the 5 most relevant chunks from the index for the given question.</p><pre><code class="language-julia hljs"># assumes you have an existing index `index`
retriever = SimpleRetriever()

result = retrieve(retriever,
    index,
    &quot;What is the capital of France?&quot;,
    top_n = 5)

# or use the default retriever (same as above)
result = retrieve(retriever,
    index,
    &quot;What is the capital of France?&quot;,
    top_n = 5)</code></pre><p>Apply more advanced retrieval with question rephrasing and reranking (requires <code>COHERE_API_KEY</code>). We will obtain top 100 chunks from embeddings (<code>top_k</code>) and top 5 chunks from reranking (<code>top_n</code>).</p><pre><code class="language-julia hljs">retriever = AdvancedRetriever()

result = retrieve(retriever, index, question; top_k=100, top_n=5)</code></pre><p>You can use the <code>retriever</code> to customize your retrieval strategy or directly change the strategy types in the <code>retrieve</code> kwargs!</p><p>Example of using locally-hosted model hosted on <code>localhost:8080</code>:</p><pre><code class="language-julia hljs">retriever = SimpleRetriever()
result = retrieve(retriever, index, question;
    rephraser_kwargs = (; model = &quot;custom&quot;),
    embedder_kwargs = (; model = &quot;custom&quot;),
    tagger_kwargs = (; model = &quot;custom&quot;), api_kwargs = (;
        url = &quot;http://localhost:8080&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/retrieval.jl#L947-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.run_qa_evals-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:RAGTools.QAEvalItem}}" href="#RAGTools.run_qa_evals-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:RAGTools.QAEvalItem}}"><code>RAGTools.run_qa_evals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_qa_evals(index::AbstractChunkIndex, qa_items::AbstractVector{&lt;:QAEvalItem};
    api_kwargs::NamedTuple = NamedTuple(),
    airag_kwargs::NamedTuple = NamedTuple(),
    qa_evals_kwargs::NamedTuple = NamedTuple(),
    verbose::Bool = true, parameters_dict::Dict{Symbol, &lt;:Any} = Dict{Symbol, Any}())</code></pre><p>Evaluates a vector of <code>QAEvalItem</code>s and returns a vector <code>QAEvalResult</code>.  This function assesses the relevance and accuracy of the answers generated in a QA evaluation context.</p><p>See <code>?run_qa_evals</code> for more details.</p><p><strong>Arguments</strong></p><ul><li><code>qa_items::AbstractVector{&lt;:QAEvalItem}</code>: The vector of QA evaluation items containing the questions and their answers.</li><li><code>verbose::Bool</code>: If <code>true</code>, enables verbose logging. Defaults to <code>true</code>.</li><li><code>api_kwargs::NamedTuple</code>: Parameters that will be forwarded to the API calls. See <code>?aiextract</code> for details.</li><li><code>airag_kwargs::NamedTuple</code>: Parameters that will be forwarded to <code>airag</code> calls. See <code>?airag</code> for details.</li><li><code>qa_evals_kwargs::NamedTuple</code>: Parameters that will be forwarded to <code>run_qa_evals</code> calls. See <code>?run_qa_evals</code> for details.</li><li><code>parameters_dict::Dict{Symbol, Any}</code>: Track any parameters used for later evaluations. Keys must be Symbols.</li></ul><p><strong>Returns</strong></p><p><code>Vector{QAEvalResult}</code>: Vector of evaluation results that includes various scores and metadata related to the QA evaluation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">index = &quot;...&quot; # Assuming a proper index is defined
qa_items = [QAEvalItem(question=&quot;What is the capital of France?&quot;, answer=&quot;Paris&quot;, context=&quot;France is a country in Europe.&quot;),
            QAEvalItem(question=&quot;What is the capital of Germany?&quot;, answer=&quot;Berlin&quot;, context=&quot;Germany is a country in Europe.&quot;)]

# Let&#39;s run a test with `top_k=5`
results = run_qa_evals(index, qa_items; airag_kwargs=(;top_k=5), parameters_dict=Dict(:top_k =&gt; 5))

# Filter out the &quot;failed&quot; calls
results = filter(x-&gt;!isnothing(x.answer_score), results);

# See average judge score
mean(x-&gt;x.answer_score, results)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/evaluation.jl#L221-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.run_qa_evals-Tuple{RAGTools.QAEvalItem, RAGResult}" href="#RAGTools.run_qa_evals-Tuple{RAGTools.QAEvalItem, RAGResult}"><code>RAGTools.run_qa_evals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_qa_evals(qa_item::QAEvalItem, ctx::RAGResult; verbose::Bool = true,
             parameters_dict::Dict{Symbol, &lt;:Any}, judge_template::Symbol = :RAGJudgeAnswerFromContext,
             model_judge::AbstractString, api_kwargs::NamedTuple = NamedTuple()) -&gt; QAEvalResult</code></pre><p>Evaluates a single <code>QAEvalItem</code> using RAG details (<code>RAGResult</code>) and returns a <code>QAEvalResult</code> structure. This function assesses the relevance and accuracy of the answers generated in a QA evaluation context.</p><p><strong>Arguments</strong></p><ul><li><code>qa_item::QAEvalItem</code>: The QA evaluation item containing the question and its answer.</li><li><code>ctx::RAGResult</code>: The RAG result used for generating the QA pair, including the original context and the answers. Comes from <code>airag(...; return_context=true)</code></li><li><code>verbose::Bool</code>: If <code>true</code>, enables verbose logging. Defaults to <code>true</code>.</li><li><code>parameters_dict::Dict{Symbol, Any}</code>: Track any parameters used for later evaluations. Keys must be Symbols.</li><li><code>judge_template::Symbol</code>: The template symbol for the AI model used to judge the answer. Defaults to <code>:RAGJudgeAnswerFromContext</code>.</li><li><code>model_judge::AbstractString</code>: The AI model used for judging the answer&#39;s quality.  Defaults to standard chat model, but it is advisable to use more powerful model GPT-4.</li><li><code>api_kwargs::NamedTuple</code>: Parameters that will be forwarded to the API endpoint.</li></ul><p><strong>Returns</strong></p><p><code>QAEvalResult</code>: An evaluation result that includes various scores and metadata related to the QA evaluation.</p><p><strong>Notes</strong></p><ul><li>The function computes a retrieval score and rank based on how well the context matches the QA context.</li><li>It then uses the <code>judge_template</code> and <code>model_judge</code> to score the answer&#39;s accuracy and relevance.</li><li>In case of errors during evaluation, the function logs a warning (if <code>verbose</code> is <code>true</code>) and the <code>answer_score</code> will be set to <code>nothing</code>.</li></ul><p><strong>Examples</strong></p><p>Evaluating a QA pair using a specific context and model:</p><pre><code class="language-julia hljs">qa_item = QAEvalItem(question=&quot;What is the capital of France?&quot;, answer=&quot;Paris&quot;, context=&quot;France is a country in Europe.&quot;)
ctx = RAGResult(source=&quot;Wikipedia&quot;, context=&quot;France is a country in Europe.&quot;, answer=&quot;Paris&quot;)
parameters_dict = Dict(&quot;param1&quot; =&gt; &quot;value1&quot;, &quot;param2&quot; =&gt; &quot;value2&quot;)

eval_result = run_qa_evals(qa_item, ctx, parameters_dict=parameters_dict, model_judge=&quot;MyAIJudgeModel&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/evaluation.jl#L145-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.score_retrieval_hit-Tuple{AbstractString, Vector{&lt;:AbstractString}}" href="#RAGTools.score_retrieval_hit-Tuple{AbstractString, Vector{&lt;:AbstractString}}"><code>RAGTools.score_retrieval_hit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns 1.0 if <code>context</code> overlaps or is contained within any of the <code>candidate_context</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/evaluation.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.score_retrieval_rank-Tuple{AbstractString, Vector{&lt;:AbstractString}}" href="#RAGTools.score_retrieval_rank-Tuple{AbstractString, Vector{&lt;:AbstractString}}"><code>RAGTools.score_retrieval_rank</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns Integer rank of the position where <code>context</code> overlaps or is contained within a <code>candidate_context</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/evaluation.jl#L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.score_to_unit_scale-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#RAGTools.score_to_unit_scale-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>RAGTools.score_to_unit_scale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">score_to_unit_scale(x::AbstractVector{T}) where T&lt;:Real</code></pre><p>Shift and scale a vector of scores to the unit scale [0, 1].</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">x = [1.0, 2.0, 3.0, 4.0, 5.0]
scaled_x = score_to_unit_scale(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L780-L790">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.set_node_style!-Tuple{TrigramAnnotater, RAGTools.AnnotatedNode}" href="#RAGTools.set_node_style!-Tuple{TrigramAnnotater, RAGTools.AnnotatedNode}"><code>RAGTools.set_node_style!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_node_style!(::TrigramAnnotater, node::AnnotatedNode;
    low_threshold::Float64 = 0.0, medium_threshold::Float64 = 0.5, high_threshold::Float64 = 1.0,
    default_styler::AbstractAnnotationStyler = Styler(),
    low_styler::AbstractAnnotationStyler = Styler(color = :magenta, bold = false),
    medium_styler::AbstractAnnotationStyler = Styler(color = :blue, bold = false),
    high_styler::AbstractAnnotationStyler = Styler(color = :nothing, bold = false),
    bold_multihits::Bool = false)</code></pre><p>Sets style of <code>node</code> based on the provided rules</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L151-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.setpropertynested-Tuple{NamedTuple, Vector{Symbol}, Symbol, Any}" href="#RAGTools.setpropertynested-Tuple{NamedTuple, Vector{Symbol}, Symbol, Any}"><code>RAGTools.setpropertynested</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setpropertynested(nt::NamedTuple, parent_keys::Vector{Symbol},
    key::Symbol,
    value</code></pre><p>)</p><p>Setter for a property <code>key</code> in a nested NamedTuple <code>nt</code>, where the property is nested to a key in <code>parent_keys</code>.</p><p>Useful for nested kwargs where we want to change some property in <code>parent_keys</code> subset (eg, <code>model</code> in <code>retriever_kwargs</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">kw = (; abc = (; def = &quot;x&quot;))
setpropertynested(kw, [:abc], :def, &quot;y&quot;)
# Output: (abc = (def = &quot;y&quot;,),)</code></pre><p>Practical example of changing all <code>model</code> keys in CHAT-based steps in the pipeline:</p><pre><code class="language-julia hljs"># changes :model to &quot;gpt4t&quot; whenever the parent key is in the below list (chat-based steps)
setpropertynested(kwargs,
    [:rephraser_kwargs, :tagger_kwargs, :answerer_kwargs, :refiner_kwargs],
    :model, &quot;gpt4t&quot;)</code></pre><p>Or changing an embedding model (across both indexer and retriever steps, because it&#39;s same step name):</p><pre><code class="language-julia hljs">kwargs = setpropertynested(
        kwargs, [:embedder_kwargs],
        :model, &quot;text-embedding-3-large&quot;
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L489-L521">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.split_into_code_and_sentences-Tuple{Union{SubString{String}, String}}" href="#RAGTools.split_into_code_and_sentences-Tuple{Union{SubString{String}, String}}"><code>RAGTools.split_into_code_and_sentences</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">split_into_code_and_sentences(input::Union{String, SubString{String}})</code></pre><p>Splits text block into code or text and sub-splits into units.</p><p>If code block, it splits by newline but keep the <code>group_id</code> the same (to have the same source) If text block, splits into sentences, bullets, etc., provides different <code>group_id</code> (to have different source)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L374-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.tags_extract-Tuple{RAGTools.Tag}" href="#RAGTools.tags_extract-Tuple{RAGTools.Tag}"><code>RAGTools.tags_extract</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tags_extract(item::Tag)
tags_extract(tags::Vector{Tag})</code></pre><p>Extracts the <code>Tag</code> item into a string of the form <code>category:::value</code> (lowercased and spaces replaced with underscores).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">msg = aiextract(:RAGExtractMetadataShort; return_type=MaybeTags, text=&quot;I like package DataFrames&quot;, instructions=&quot;None.&quot;)
metadata = tags_extract(msg.content.items)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/preparation.jl#L467-L478">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.tavily_api-Tuple{}" href="#RAGTools.tavily_api-Tuple{}"><code>RAGTools.tavily_api</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tavily_api(;
    api_key::AbstractString,
    endpoint::String = &quot;search&quot;,
    url::AbstractString = &quot;https://api.tavily.com&quot;,
    http_kwargs::NamedTuple = NamedTuple(),
    kwargs...)</code></pre><p>Sends API requests to <a href="https://tavily.com">Tavily</a> and returns the response.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/api_services.jl#L38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.token_with_boundaries-Tuple{Union{Nothing, AbstractString}, AbstractString, Union{Nothing, AbstractString}}" href="#RAGTools.token_with_boundaries-Tuple{Union{Nothing, AbstractString}, AbstractString, Union{Nothing, AbstractString}}"><code>RAGTools.token_with_boundaries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">token_with_boundaries(
    prev_token::Union{Nothing, AbstractString}, curr_token::AbstractString,
    next_token::Union{Nothing, AbstractString})</code></pre><p>Joins the three tokens together. Useful to add boundary tokens (like spaces vs brackets) to the <code>curr_token</code> to improve the matched context (ie, separate partial matches from exact match)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L294-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.tokenize-Tuple{Union{SubString{String}, String}}" href="#RAGTools.tokenize-Tuple{Union{SubString{String}, String}}"><code>RAGTools.tokenize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tokenize(input::Union{String, SubString{String}})</code></pre><p>Tokenizes provided <code>input</code> by spaces, special characters or Julia symbols (eg, <code>=&gt;</code>).</p><p>Unlike other tokenizers, it aims to lossless - ie, keep both the separated text and the separators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L219-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.translate_positions_to_parent-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:Integer}}" href="#RAGTools.translate_positions_to_parent-Tuple{RAGTools.AbstractChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.translate_positions_to_parent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate_positions_to_parent(index::AbstractChunkIndex, positions::AbstractVector{&lt;:Integer})</code></pre><p>Translate positions to the parent index. Useful to convert between positions in a view and the original index.</p><p>Used whenever a <code>chunkdata()</code> is used to re-align positions in case index is a view.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.translate_positions_to_parent-Tuple{SubChunkIndex, AbstractVector{&lt;:Integer}}" href="#RAGTools.translate_positions_to_parent-Tuple{SubChunkIndex, AbstractVector{&lt;:Integer}}"><code>RAGTools.translate_positions_to_parent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate_positions_to_parent(
    index::SubChunkIndex, pos::AbstractVector{&lt;:Integer})</code></pre><p>Translate positions to the parent index. Useful to convert between positions in a view and the original index.</p><p>Used whenever a <code>chunkdata()</code> or <code>tags()</code> are used to re-align positions to the &quot;parent&quot; index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/types.jl#L504-L511">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.trigram_support!-Union{Tuple{F2}, Tuple{F1}, Tuple{RAGTools.AnnotatedNode, AbstractVector}, Tuple{RAGTools.AnnotatedNode, AbstractVector, F1}, Tuple{RAGTools.AnnotatedNode, AbstractVector, F1, F2}} where {F1&lt;:Function, F2&lt;:Function}" href="#RAGTools.trigram_support!-Union{Tuple{F2}, Tuple{F1}, Tuple{RAGTools.AnnotatedNode, AbstractVector}, Tuple{RAGTools.AnnotatedNode, AbstractVector, F1}, Tuple{RAGTools.AnnotatedNode, AbstractVector, F1, F2}} where {F1&lt;:Function, F2&lt;:Function}"><code>RAGTools.trigram_support!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigram_support!(parent_node::AnnotatedNode,
    context_trigrams::AbstractVector, trigram_func::F1 = trigrams, token_transform::F2 = identity;
    skip_trigrams::Bool = false, min_score::Float64 = 0.5,
    min_source_score::Float64 = 0.25,
    stop_words::AbstractVector{&lt;:String} = STOPWORDS,
    styler_kwargs...) where {F1 &lt;: Function, F2 &lt;: Function}</code></pre><p>Find if the <code>parent_node.content</code> is supported by the provided <code>context_trigrams</code>.</p><p>Logic:</p><ul><li>Split the <code>parent_node.content</code> into tokens</li><li>Create an <code>AnnotatedNode</code> for each token</li><li>If <code>skip_trigrams</code> is enabled, it looks for an exact match in the <code>context_trigrams</code></li><li>If no exact match found, it counts trigram-based match (include the surrounding tokens for better contextual awareness) as a score</li><li>Then it sets the style of the node based on the score</li><li>Lastly, it aligns the styles of neighboring nodes with <code>score==nothing</code> (eg, single character tokens)</li><li>Then, it rolls up the scores and sources to the parent node</li></ul><p>For diagnostics, you can use <code>AbstractTrees.print_tree(parent_node)</code> to see the tree structure of each token and its score.</p><p><strong>Example</strong></p><p>```julia context<em>trigrams = text</em>to_trigrams.([&quot;This IS a test.&quot;, &quot;Another test.&quot;,     &quot;More content here.&quot;])</p><p>node = AnnotatedNode(content = &quot;xyz&quot;)  trigram<em>support!(node, context</em>trigrams) # updates node.children! `<code></code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/annotation.jl#L215-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.trigrams-Tuple{AbstractString}" href="#RAGTools.trigrams-Tuple{AbstractString}"><code>RAGTools.trigrams</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigrams(input_string::AbstractString; add_word::AbstractString = &quot;&quot;)</code></pre><p>Splits provided <code>input_string</code> into a vector of trigrams (combination of three consecutive characters found in the <code>input_string</code>).</p><p>If <code>add_word</code> is provided, it is added to the resulting array. Useful to add the full word itself to the resulting array for exact match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L232-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RAGTools.trigrams_hashed-Tuple{AbstractString}" href="#RAGTools.trigrams_hashed-Tuple{AbstractString}"><code>RAGTools.trigrams_hashed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trigrams_hashed(input_string::AbstractString; add_word::AbstractString = &quot;&quot;)</code></pre><p>Splits provided <code>input_string</code> into a Set of hashed trigrams (combination of three consecutive characters found in the <code>input_string</code>).</p><p>It is more efficient for lookups in large strings (eg, &gt;100K characters).</p><p>If <code>add_word</code> is provided, it is added to the resulting array to hash. Useful to add the full word itself to the resulting array for exact match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGenAI/RAGTools.jl/blob/eddf8af12887c11c37d891a9ef9a046430fa79d7/src/utils.jl#L262-L270">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« Interface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 8 February 2025 21:01">Saturday 8 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
